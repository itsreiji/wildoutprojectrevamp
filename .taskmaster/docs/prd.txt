<rpg-method>
# Repository Planning Graph (RPG) Method - PRD Template

This template teaches you (AI or human) how to create structured, dependency-aware PRDs using the RPG methodology from Microsoft Research. The key insight: separate WHAT (functional) from HOW (structural), then connect them with explicit dependencies.

## Core Principles

1. **Dual-Semantics**: Think functional (capabilities) AND structural (code organization) separately, then map them
2. **Explicit Dependencies**: Never assume - always state what depends on what
3. **Topological Order**: Build foundation first, then layers on top
4. **Progressive Refinement**: Start broad, refine iteratively

## How to Use This Template

- Follow the instructions in each `<instruction>` block
- Look at `<example>` blocks to see good vs bad patterns
- Fill in the content sections with your project details
- The AI reading this will learn the RPG method by following along
- Task Master will parse the resulting PRD into dependency-aware tasks

## Recommended Tools for Creating PRDs

When using this template to **create** a PRD (not parse it), use **code-context-aware AI assistants** for best results:

**Why?** The AI needs to understand your existing codebase to make good architectural decisions about modules, dependencies, and integration points.

**Recommended tools:**
- **Claude Code** (claude-code CLI) - Best for structured reasoning and large contexts
- **Cursor/Windsurf** - IDE integration with full codebase context
- **Gemini CLI** (gemini-cli) - Massive context window for large codebases
- **Codex/Grok CLI** - Strong code generation with context awareness

**Note:** Once your PRD is created, `task-master parse-prd` works with any configured AI model - it just needs to read the PRD text itself, not your codebase.
</rpg-method>

---

<overview>

## Problem Statement

WildOut! is a media platform for Indonesia's creative community that currently has a React/TypeScript landing page and admin dashboard. The platform needs structured development with clear separation of concerns, dependency mapping, and phased implementation of features. The core challenge is managing complex content relationships (events, team, partners, gallery, settings) while maintaining code quality, performance, and maintainability as the platform scales from initial launch to supporting 500+ events, 50K+ members, and 100+ partners.

## Target Users

**Primary:**
- **Event Organizers**: Need to create, manage, and promote events (festivals, club nights, exhibitions, live music)
- **Platform Administrators**: Manage content, team members, partners, gallery, and site settings
- **Creative Community Members**: Browse events, discover artists, connect with venues and other creatives

**Secondary:**
- **Venue Owners**: List their venues and managed events
- **Artists/DJs**: Showcase their profiles and upcoming performances
- **Partners/Sponsors**: Brand visibility and partnership opportunities

## Success Metrics

- **Launch**: Fully functional landing page + admin dashboard deployed (v0.1.0)
- **Content Scale**: Support 500+ events, 50K+ members, 100+ partners without performance degradation
- **Admin Efficiency**: Content management operations completed in < 5 seconds per action
- **Developer Velocity**: New features implemented in phased sprints with minimal blockers
- **Code Quality**: 80%+ test coverage for critical paths, < 2 bugs per release
- **Platform Availability**: 99%+ uptime for user-facing pages

</overview>

---

<functional-decomposition>

## Capability Tree

### Capability: Event Management
Core capability for creating, updating, viewing, and managing event lifecycle across the platform.

#### Feature: Event CRUD Operations
- **Description**: Create, read, update, and delete event records with full metadata
- **Inputs**: Event form data (title, description, date, time, venue, capacity, price, artists, images)
- **Outputs**: Event record with unique ID, timestamps, and validation status
- **Behavior**: Validate input, persist to Supabase, trigger side effects (cache invalidation, notifications)

#### Feature: Event Status Lifecycle
- **Description**: Manage event progression through states: draft → upcoming → ongoing → completed → archived
- **Inputs**: Event ID, new status, transition reason
- **Outputs**: Updated event with audit trail
- **Behavior**: Enforce valid state transitions, prevent invalid operations (e.g., complete past events)

#### Feature: Event Gallery & Media
- **Description**: Manage featured images, gallery photos, and media assets for events
- **Inputs**: Event ID, image files, captions, metadata
- **Outputs**: Stored media with URLs, thumbnails, and metadata
- **Behavior**: Upload to Supabase Storage, generate thumbnails, validate file types

#### Feature: Event Lineup & Artists
- **Description**: Manage artists performing at events with roles and metadata
- **Inputs**: Event ID, artist profiles, roles (Headliner, Supporting, Opening)
- **Outputs**: Artist lineup with ordering and role assignments
- **Behavior**: Link artist profiles, validate role assignments, handle artist availability

### Capability: Content Management System (CMS)
Admin-facing content management for site configuration, static content, and metadata.

#### Feature: Team Management
- **Description**: Create and maintain team member profiles with photos, bios, contact info, and roles
- **Inputs**: Team member form (name, bio, role, photo, social links)
- **Outputs**: Team member record with profile image and metadata
- **Behavior**: Validate data, upload photos, create/update team roster

#### Feature: Partner/Sponsor Management
- **Description**: Manage brand partners and sponsors with categories and branding
- **Inputs**: Partner name, category, logo, links, metadata
- **Outputs**: Partner record with branding assets
- **Behavior**: Validate categories, organize by sponsorship tier

#### Feature: Gallery Management (Site-wide)
- **Description**: Manage shared photo gallery for past events and promotional content
- **Inputs**: Photo files, captions, event associations, metadata
- **Outputs**: Gallery item with URLs and metadata
- **Behavior**: Store photos, organize by events/collections, generate thumbnails

#### Feature: Hero & Landing Content
- **Description**: Manage landing page hero section with stats, imagery, and featured content
- **Inputs**: Hero title, subtitle, featured event, background image, statistics
- **Outputs**: Hero configuration with media assets
- **Behavior**: Update hero display, manage featured event rotation

#### Feature: About Section Management
- **Description**: Manage company/platform about section and history
- **Inputs**: About text, founding year, features list, images
- **Outputs**: About configuration for landing page
- **Behavior**: Store and render about information

#### Feature: Site Settings & Configuration
- **Description**: Global site settings like contact info, social media links, branding
- **Inputs**: Site config (email, phone, social links, metadata)
- **Outputs**: Site configuration document
- **Behavior**: Update settings, provide read access to all consumers

### Capability: Public Content Presentation
User-facing presentation of events, community content, and discovery features.

#### Feature: Landing Page Rendering
- **Description**: Render complete landing page with hero, featured events, partners, team, about
- **Inputs**: Landing page configuration, current content from CMS
- **Outputs**: Fully rendered HTML/React components
- **Behavior**: Compose hero, events list, team section, partners, about, footer

#### Feature: Event Browsing & Filtering
- **Description**: Display all events with filtering, sorting, and search capabilities
- **Inputs**: Query parameters (date range, category, venue, artist, etc.)
- **Outputs**: Filtered event list with pagination
- **Behavior**: Query events by criteria, implement pagination, real-time search

#### Feature: Event Detail View
- **Description**: Detailed view of single event with full information and related content
- **Inputs**: Event ID
- **Outputs**: Complete event page with media gallery, lineup, venue details
- **Behavior**: Load event data, resolve related entities (artists, venue), lazy-load gallery

#### Feature: Community Discovery
- **Description**: Discover artists, venues, and creative community members
- **Inputs**: Search query, filter criteria
- **Outputs**: Community member profiles or listings
- **Behavior**: Search across artists and venues, display profiles

### Capability: Data Persistence & Synchronization
Database operations, caching, and real-time data synchronization.

#### Feature: Supabase Integration
- **Description**: All database operations through Supabase client with proper error handling
- **Inputs**: Database queries, mutations, subscriptions
- **Outputs**: Data from PostgreSQL database
- **Behavior**: Execute queries, handle auth, manage connections, retry logic

#### Feature: Real-time Data Subscription
- **Description**: Subscribe to real-time updates for collaborative editing and live content
- **Inputs**: Subscription filters (event changes, new uploads)
- **Outputs**: Live updates pushed to clients
- **Behavior**: Use Supabase realtime subscriptions, trigger UI updates

#### Feature: Caching & Performance Optimization
- **Description**: Client-side caching to reduce API calls and improve performance
- **Inputs**: Data fetches, cache invalidation signals
- **Outputs**: Cached data served from local state
- **Behavior**: Implement React Context caching, invalidate on mutations

#### Feature: Error Recovery & Resilience
- **Description**: Handle failures, retries, and partial data scenarios gracefully
- **Inputs**: Failed operations, network errors, timeout scenarios
- **Outputs**: User-friendly error messages, retry mechanisms
- **Behavior**: Implement exponential backoff, fallback UI states, user notifications

### Capability: User Interface & Experience
Frontend components and interactions for both public and admin interfaces.

#### Feature: Responsive Component Library
- **Description**: Reusable, accessible, responsive UI components
- **Inputs**: Component configuration, content, state
- **Outputs**: Rendered React components with Tailwind styling
- **Behavior**: Use Radix UI primitives, implement shadcn/ui patterns, support dark mode

#### Feature: Form Management & Validation
- **Description**: Complex form handling with validation, error states, and submission
- **Inputs**: Form schema, user input, validation rules
- **Outputs**: Validated data ready for persistence
- **Behavior**: Use React Hook Form, show real-time validation, handle async validation

#### Feature: Data Visualization
- **Description**: Charts and analytics for dashboard (event stats, attendance, partner metrics)
- **Inputs**: Event data, attendance records, analytics
- **Outputs**: Visual charts and reports
- **Behavior**: Use Recharts for data visualization, aggregate metrics

#### Feature: Modal & Dialog Management
- **Description**: Modals for confirmations, forms, detail views
- **Inputs**: Modal type, content, actions
- **Outputs**: Rendered modal with proper focus management
- **Behavior**: Use Radix Dialog, manage z-stacking, handle dismissals

#### Feature: Navigation & Routing
- **Description**: Client-side routing between landing page, all-events page, and admin dashboard
- **Inputs**: Route path, router state
- **Outputs**: Correct page component rendered
- **Behavior**: Custom router implementation using React Context and History API

#### Feature: Toast Notifications
- **Description**: Non-blocking notifications for success, error, and info messages
- **Inputs**: Toast message, type, duration
- **Outputs**: Toast displayed in UI
- **Behavior**: Use Sonner library, auto-dismiss, stackable

### Capability: Authentication & Authorization
User access control and admin privileges management.

#### Feature: Admin Authentication
- **Description**: Authentication for admin dashboard access
- **Inputs**: Credentials
- **Outputs**: Auth token, user session
- **Behavior**: Validate credentials, maintain session, handle logout

#### Feature: Role-Based Access Control (RBAC)
- **Description**: Different permission levels for different user roles
- **Inputs**: User role, resource being accessed
- **Outputs**: Authorization decision (allowed/denied)
- **Behavior**: Check user role, enforce access policies

### Capability: Performance & Analytics
Monitoring, optimization, and user behavior tracking.

#### Feature: Performance Monitoring
- **Description**: Track page load times, component render performance, API response times
- **Inputs**: Performance metrics
- **Outputs**: Performance reports and alerts
- **Behavior**: Collect metrics, analyze trends, identify bottlenecks

#### Feature: Event Analytics
- **Description**: Track event views, clicks, attendance, and engagement metrics
- **Inputs**: User interactions, event data
- **Outputs**: Analytics dashboard
- **Behavior**: Aggregate event metrics, generate reports

</functional-decomposition>

---

<structural-decomposition>

## Repository Structure

```
project-root/
├── src/
│   ├── components/           # UI Components
│   │   ├── dashboard/        # Dashboard-specific components
│   │   │   ├── DashboardLayout.tsx
│   │   │   ├── DashboardHome.tsx
│   │   │   ├── DashboardEvents.tsx
│   │   │   ├── DashboardEventsNew.tsx
│   │   │   ├── DashboardAbout.tsx
│   │   │   ├── DashboardGallery.tsx
│   │   │   ├── DashboardHero.tsx
│   │   │   ├── DashboardPartners.tsx
│   │   │   ├── DashboardSettings.tsx
│   │   │   ├── DashboardTeam.tsx
│   │   │   └── index.ts
│   │   ├── ui/               # Reusable UI primitives (shadcn/ui style)
│   │   ├── figma/            # Figma asset components
│   │   ├── LandingPage.tsx
│   │   ├── AllEventsPage.tsx
│   │   ├── Dashboard.tsx
│   │   ├── Router.tsx
│   │   └── index.ts
│   ├── contexts/             # React Context providers
│   │   ├── ContentContext.tsx
│   │   └── index.ts
│   ├── hooks/                # Custom React hooks
│   │   ├── useEvents.ts
│   │   ├── useRouter.ts
│   │   └── index.ts
│   ├── utils/                # Utility functions
│   │   ├── formatting.ts
│   │   ├── validation.ts
│   │   ├── api.ts
│   │   └── index.ts
│   ├── supabase/             # Supabase configuration
│   │   ├── client.ts
│   │   ├── functions/
│   │   │   └── server/
│   │   └── types.ts
│   ├── types/                # Global TypeScript types
│   │   ├── events.ts
│   │   ├── content.ts
│   │   └── index.ts
│   ├── styles/               # Global styles
│   │   ├── globals.css
│   │   └── index.css
│   ├── App.tsx               # Root app component
│   ├── main.tsx              # React DOM entry point
│   └── index.css
├── .taskmaster/              # Task Master configuration
│   ├── docs/
│   │   └── prd.txt
│   ├── config.json
│   └── state.json
├── .kilo/                    # Kilo configuration
│   └── mcp.json
├── .cursor/                  # Cursor configuration
│   ├── mcp.json
│   └── rules/
├── public/                   # Static assets
├── vite.config.ts            # Vite configuration
├── tailwind.config.js        # Tailwind CSS configuration
├── package.json              # NPM dependencies
├── tsconfig.json             # TypeScript configuration
├── index.html                # HTML entry point
└── README.md                 # Project documentation
```

## Module Definitions

### Module: ContentContext (Maps to: Data Persistence & Synchronization + State Management)
- **Responsibility**: Global state management for all content entities (events, team, partners, gallery, hero, about, settings)
- **File structure**:
  ```
  contexts/
  ├── ContentContext.tsx      # Context provider and types
  └── index.ts                # Public exports
  ```
- **Exports**:
  - `ContentProvider` - Context provider component
  - `useContent()` - Hook to access content context
  - Types: Event, Team, Partner, GalleryItem, etc.

### Module: Router (Maps to: Navigation & Routing)
- **Responsibility**: Client-side routing without external router library
- **File structure**:
  ```
  components/
  ├── Router.tsx              # Router context and provider
  └── [other components using routes]
  ```
- **Exports**:
  - `RouterProvider` - Router context provider
  - `useRouter()` - Hook to access current page and navigation
  - Route definitions: landing, admin, all-events

### Module: Dashboard Components (Maps to: Content Management System + User Interface)
- **Responsibility**: Admin dashboard UI and content management operations
- **File structure**:
  ```
  components/dashboard/
  ├── DashboardLayout.tsx     # Main dashboard layout
  ├── DashboardHome.tsx       # Dashboard overview
  ├── DashboardEvents.tsx     # Event listing and management
  ├── DashboardEventsNew.tsx  # Event creation form
  ├── DashboardTeam.tsx       # Team member management
  ├── DashboardPartners.tsx   # Partner/sponsor management
  ├── DashboardGallery.tsx    # Gallery management
  ├── DashboardHero.tsx       # Hero section management
  ├── DashboardAbout.tsx      # About section management
  ├── DashboardSettings.tsx   # Site settings management
  └── index.ts                # Public exports
  ```
- **Exports**:
  - `Dashboard` - Root dashboard component
  - Individual dashboard page components

### Module: UI Components (Maps to: User Interface & Experience)
- **Responsibility**: Reusable, accessible UI primitives
- **File structure**:
  ```
  components/ui/
  ├── button.tsx
  ├── input.tsx
  ├── dialog.tsx
  ├── form.tsx
  ├── select.tsx
  ├── accordion.tsx
  ├── alert.tsx
  ├── avatar.tsx
  ├── badge.tsx
  ├── card.tsx
  ├── checkbox.tsx
  ├── dropdown-menu.tsx
  ├── popover.tsx
  ├── toast.tsx
  ├── sonner.tsx
  └── [other UI primitives]
  ```
- **Exports**: Individual UI component exports

### Module: LandingPage (Maps to: Public Content Presentation)
- **Responsibility**: Render complete landing page with all sections
- **File structure**:
  ```
  components/
  ├── LandingPage.tsx         # Main landing page component
  └── [hero, footer, sections as needed]
  ```
- **Exports**:
  - `LandingPage` - Root landing page component

### Module: AllEventsPage (Maps to: Public Content Presentation)
- **Responsibility**: Event browsing, filtering, and discovery
- **File structure**:
  ```
  components/
  ├── AllEventsPage.tsx       # Main events page
  └── [event filters, event cards, pagination]
  ```
- **Exports**:
  - `AllEventsPage` - Events listing component

### Module: Supabase (Maps to: Data Persistence & Synchronization)
- **Responsibility**: Supabase client configuration and integration
- **File structure**:
  ```
  supabase/
  ├── client.ts               # Supabase client initialization
  ├── types.ts                # Database types
  └── functions/              # Edge Functions
      └── server/             # Hono-based server functions
  ```
- **Exports**:
  - `supabaseClient` - Configured Supabase client
  - Database types and schemas

### Module: Hooks (Maps to: User Interface & Experience)
- **Responsibility**: Custom React hooks for business logic
- **File structure**:
  ```
  hooks/
  ├── useEvents.ts            # Event-related operations
  ├── useRouter.ts            # Navigation hook
  ├── useForm.ts              # Form management helpers
  └── index.ts                # Public exports
  ```
- **Exports**: Custom hook functions

### Module: Utils (Maps to: Data Persistence & Synchronization + UI)
- **Responsibility**: Utility functions for formatting, validation, API calls
- **File structure**:
  ```
  utils/
  ├── formatting.ts           # Date, string formatting utilities
  ├── validation.ts           # Input validation rules
  ├── api.ts                  # API helper functions
  └── index.ts                # Public exports
  ```
- **Exports**: Utility functions

### Module: Types (Maps to: Foundation)
- **Responsibility**: Global TypeScript type definitions
- **File structure**:
  ```
  types/
  ├── events.ts               # Event-related types
  ├── content.ts              # Content entity types
  └── index.ts                # Public exports
  ```
- **Exports**: Type definitions for entire application

</structural-decomposition>

---

<dependency-graph>

## Dependency Chain

### Foundation Layer (Phase 0)
No dependencies - these are built first.

- **Types**: Global TypeScript type definitions (events, content, API responses)
- **Styles**: Global CSS and Tailwind configuration
- **Utils**: Basic utility functions (formatting, validation, common helpers)

### UI Layer (Phase 1)
- **UI Components**: Depends on [Types, Styles]
  - Reusable Radix UI wrapped components, shadcn/ui patterns
  - Button, input, dialog, forms, etc.

### Configuration & Integration (Phase 2)
- **Supabase Client**: Depends on [Types]
  - Supabase JavaScript client configuration
  - Database type definitions and schemas
  
- **React Hooks**: Depends on [Types, Utils, Supabase Client]
  - Custom hooks for state management and effects

### State Management (Phase 3)
- **ContentContext**: Depends on [Types, Supabase Client, Hooks]
  - Global React Context for content management
  - Manages events, team, partners, gallery, hero, about, settings

- **Router**: Depends on [React]
  - Client-side routing context and navigation

### Component Layer (Phase 4)
- **UI Components (App-specific)**: Depends on [UI Components, ContentContext, Router]
  - LandingPage components (hero, footer, sections)
  - AllEventsPage components (filters, event cards)
  - Dashboard components (all subpages)

### Page Components (Phase 5)
- **LandingPage**: Depends on [UI Components (app-specific), ContentContext, Router]
  - Main landing page assembly
  
- **AllEventsPage**: Depends on [UI Components (app-specific), ContentContext, Router]
  - Events browsing and filtering
  
- **Dashboard**: Depends on [Dashboard Components, ContentContext, Router, UI Components]
  - Admin interface assembly

### Root Application (Phase 6)
- **App**: Depends on [LandingPage, AllEventsPage, Dashboard, Router, ContentContext, ContentProvider]
  - Root application component that orchestrates all pages

</dependency-graph>

---

<implementation-roadmap>

## Development Phases

### Phase 0: Foundation & Configuration
**Goal**: Establish project foundation with types, styles, utilities, and configuration.

**Entry Criteria**: Clean repository with package.json and build config

**Tasks**:
- [ ] Setup TypeScript types for all domain entities (Event, Team, Partner, Gallery, HeroContent, About, Settings)
  - Acceptance criteria: All types defined, no `any` types, comprehensive interfaces
  - Test strategy: Type compilation without errors, IntelliSense verification

- [ ] Configure Tailwind CSS and global styles
  - Acceptance criteria: Tailwind working in vite, custom theme configured, globals.css present
  - Test strategy: Manual check of styling in browser

- [ ] Create utility functions (formatting, validation, common helpers)
  - Acceptance criteria: Utility functions for date formatting, input validation, API helpers
  - Test strategy: Unit tests for all utility functions

- [ ] Initialize Supabase client configuration
  - Acceptance criteria: Supabase client properly configured with project ID, environment variables
  - Test strategy: Client can connect to Supabase without errors

**Exit Criteria**: TypeScript compiler passes, all utilities have tests, Supabase client ready for use

**Delivers**: Foundation layer ready for Phase 1, no TypeScript errors throughout project

---

### Phase 1: UI Component Library
**Goal**: Build reusable, accessible UI component library using Radix UI and Tailwind.

**Entry Criteria**: Phase 0 complete

**Tasks**:
- [ ] Implement core UI components (Button, Input, Dialog, Form, Select, Tabs)
  - Depends on: [Types, Styles]
  - Acceptance criteria: All components render, accessible, Tailwind styled, support dark mode
  - Test strategy: Component storybook or manual testing

- [ ] Implement data display components (Card, Badge, Avatar, Alert, Accordion)
  - Depends on: [Core UI components]
  - Acceptance criteria: Components display data correctly, responsive
  - Test strategy: Manual testing on different screen sizes

- [ ] Implement form components (FormField, Checkbox, RadioGroup, DatePicker)
  - Depends on: [Core UI components]
  - Acceptance criteria: Form components integrate with React Hook Form, validation visible
  - Test strategy: Manual form submission testing

- [ ] Implement layout components (SideNav, Header, Footer, Grid layouts)
  - Depends on: [Core UI components]
  - Acceptance criteria: Responsive layouts work on mobile and desktop
  - Test strategy: Mobile and desktop viewport testing

**Exit Criteria**: 30+ UI components implemented and tested, component library ready for app development

**Delivers**: Complete UI component library for application pages

---

### Phase 2: State Management & Configuration
**Goal**: Setup global state management and application configuration.

**Entry Criteria**: Phase 1 complete

**Tasks**:
- [ ] Implement ContentContext for global state (events, team, partners, gallery, hero, about, settings)
  - Depends on: [Types, Supabase Client]
  - Acceptance criteria: Context provides access to all content entities, loading states, error handling
  - Test strategy: Unit tests for context operations, verify state updates correctly

- [ ] Implement Router context for navigation between pages
  - Depends on: [React]
  - Acceptance criteria: Router supports landing, admin, all-events pages, History API integration
  - Test strategy: Navigation between pages works, URL updates correctly

- [ ] Create custom React hooks (useEvents, useRouter, useForm helpers)
  - Depends on: [ContentContext, Types]
  - Acceptance criteria: Hooks simplify component logic, proper dependency arrays, no memory leaks
  - Test strategy: Hook unit tests, verify effect cleanup

**Exit Criteria**: Global state management fully functional, routing works, hooks tested

**Delivers**: State management layer ready for UI development

---

### Phase 3: Dashboard - Core Infrastructure
**Goal**: Build dashboard layout and core management interface structure.

**Entry Criteria**: Phase 2 complete

**Tasks**:
- [ ] Implement DashboardLayout with navigation, sidebar, and main content area
  - Depends on: [UI Components, Router]
  - Acceptance criteria: Layout renders correctly, navigation works, responsive on all screen sizes
  - Test strategy: Manual testing of layout on desktop and tablet

- [ ] Implement DashboardHome with overview and statistics
  - Depends on: [DashboardLayout, ContentContext]
  - Acceptance criteria: Dashboard home displays key metrics from ContentContext
  - Test strategy: Verify correct data displayed from context

- [ ] Create form component wrappers for dashboard (FormField, FormInput, FormSelect with defaults)
  - Depends on: [UI Components, React Hook Form]
  - Acceptance criteria: Dashboard forms consistent, validation working
  - Test strategy: Form validation testing

**Exit Criteria**: Dashboard layout complete and responsive, form infrastructure ready

**Delivers**: Dashboard UI framework for content management pages

---

### Phase 4: Event Management
**Goal**: Implement complete event CRUD operations and event-related features.

**Entry Criteria**: Phase 3 complete

**Tasks**:
- [ ] Implement DashboardEvents listing page with event table/grid
  - Depends on: [DashboardLayout, ContentContext, UI Components]
  - Acceptance criteria: Events list displays all events, sortable/filterable, pagination
  - Test strategy: Verify correct events displayed, filtering works

- [ ] Implement DashboardEventsNew form for creating and editing events
  - Depends on: [DashboardLayout, ContentContext, Forms]
  - Acceptance criteria: Event form includes all fields (title, description, date, venue, artists, etc.), saves to database
  - Test strategy: Create event, verify it appears in list, verify data in Supabase

- [ ] Implement event gallery & media management
  - Depends on: [Event CRUD, Supabase Storage]
  - Acceptance criteria: Upload images, display thumbnails, link to events
  - Test strategy: Upload image, verify in Supabase Storage and displayed

- [ ] Implement event status lifecycle management
  - Depends on: [Event CRUD]
  - Acceptance criteria: Change event status, enforce valid transitions, audit trail
  - Test strategy: Verify status changes, invalid transitions rejected

**Exit Criteria**: Complete event CRUD working end-to-end, images uploadable, events persistent in database

**Delivers**: Fully functional event management system

---

### Phase 5: Content Management (Team, Partners, Gallery, Settings)
**Goal**: Implement management interfaces for team, partners, gallery, and site settings.

**Entry Criteria**: Phase 4 complete

**Tasks**:
- [ ] Implement DashboardTeam for team member management
  - Depends on: [DashboardLayout, ContentContext, Event CRUD patterns]
  - Acceptance criteria: Add/edit/delete team members, upload photos, CRUD operations
  - Test strategy: Create team member, verify in list and Supabase

- [ ] Implement DashboardPartners for sponsor/partner management
  - Depends on: [DashboardLayout, ContentContext, Event CRUD patterns]
  - Acceptance criteria: Manage partners, categories, logos, sponsorship info
  - Test strategy: Create partner, verify in list

- [ ] Implement DashboardGallery for site-wide gallery management
  - Depends on: [DashboardLayout, ContentContext, Media handling]
  - Acceptance criteria: Upload photos, organize by events, add metadata
  - Test strategy: Upload photos, verify display

- [ ] Implement DashboardHero and DashboardAbout for landing page content
  - Depends on: [DashboardLayout, ContentContext]
  - Acceptance criteria: Edit hero section (title, subtitle, featured event), edit about section
  - Test strategy: Verify changes appear on landing page

- [ ] Implement DashboardSettings for site configuration
  - Depends on: [DashboardLayout, ContentContext]
  - Acceptance criteria: Edit contact info, social media links, site metadata
  - Test strategy: Update settings, verify in context

**Exit Criteria**: All content management features working, all entities manageable through dashboard

**Delivers**: Complete admin dashboard for content management

---

### Phase 6: Public Pages - Landing & Events Display
**Goal**: Build public-facing landing page and events browsing experience.

**Entry Criteria**: Phase 5 complete

**Tasks**:
- [ ] Implement LandingPage with hero, featured events, team, partners sections
  - Depends on: [UI Components, ContentContext, LandingPage components]
  - Acceptance criteria: Landing page displays all sections, uses CMS content, responsive
  - Test strategy: Verify all sections render, data from context displays

- [ ] Implement AllEventsPage with filtering, search, and pagination
  - Depends on: [UI Components, ContentContext]
  - Acceptance criteria: Browse all events, filter by date/category/venue, search, pagination works
  - Test strategy: Filter events, search works, pagination navigates correctly

- [ ] Implement EventDetail modal/view with full event information
  - Depends on: [AllEventsPage, ContentContext]
  - Acceptance criteria: Show complete event details, lineup, gallery, venue info
  - Test strategy: Click event, detail view loads with correct data

- [ ] Implement responsive design and mobile optimization
  - Depends on: [LandingPage, AllEventsPage, EventDetail]
  - Acceptance criteria: Pages responsive on mobile/tablet/desktop, touch-friendly
  - Test strategy: Mobile device/emulator testing

**Exit Criteria**: Public pages fully functional and responsive, content displays from CMS

**Delivers**: Complete public-facing user experience

---

### Phase 7: Performance, Testing & Polish
**Goal**: Optimize performance, add comprehensive tests, and refine user experience.

**Entry Criteria**: Phase 6 complete

**Tasks**:
- [ ] Implement caching strategy and performance optimization
  - Depends on: [All prior phases]
  - Acceptance criteria: Page load time < 3s, cached data reduces API calls, images optimized
  - Test strategy: Lighthouse audit, network monitoring

- [ ] Add comprehensive test suite (unit, integration, E2E)
  - Depends on: [All prior phases]
  - Acceptance criteria: 80%+ coverage of critical paths, all CRUD operations tested
  - Test strategy: Run test suite, verify coverage reports

- [ ] Implement error handling and user feedback (toasts, error boundaries)
  - Depends on: [All prior phases]
  - Acceptance criteria: Graceful error handling, user sees clear error messages
  - Test strategy: Trigger errors, verify proper handling

- [ ] Polish UI/UX, add animations, finalize branding
  - Depends on: [All prior phases]
  - Acceptance criteria: Smooth transitions, professional appearance, brand consistency
  - Test strategy: Manual QA

**Exit Criteria**: v0.1.0 production-ready, all tests passing, performance optimized

**Delivers**: Polished, tested, optimized production release

---

### Phase 8: Deployment & Monitoring (Post-MVP)
**Goal**: Deploy to production and setup monitoring.

**Entry Criteria**: Phase 7 complete

**Tasks**:
- [ ] Setup CI/CD pipeline for automated testing and deployment
  - Depends on: [Test suite]
  - Acceptance criteria: Automated tests run on commit, deployment to hosting on main branch
  - Test strategy: Trigger CI/CD, verify deployment

- [ ] Deploy to production hosting
  - Depends on: [CI/CD setup]
  - Acceptance criteria: Application running in production, SSL certificate, domain pointing
  - Test strategy: Access production URL, verify functionality

- [ ] Setup monitoring and error tracking (Sentry, analytics)
  - Depends on: [Production deployment]
  - Acceptance criteria: Error tracking active, performance metrics collected
  - Test strategy: Trigger error, verify in monitoring system

**Exit Criteria**: v0.1.0 live in production, monitoring active

**Delivers**: Production-ready application with monitoring

</implementation-roadmap>

---

<test-strategy>

## Test Pyramid

```
        /\
       /E2E\       ← 10% (End-to-end, slow, comprehensive)
      /------\
     /Integration\ ← 30% (Module interactions, data flow)
    /------------\
   /  Unit Tests  \ ← 60% (Fast, isolated, deterministic)
  /----------------\
```

## Coverage Requirements

- Line coverage: 80% minimum
- Branch coverage: 75% minimum
- Function coverage: 85% minimum
- Statement coverage: 80% minimum

## Critical Test Scenarios

### Event CRUD Operations
**Happy path**:
- Create event with all required fields → Event saved and appears in list
- Edit event → Changes persist and display updates
- Delete event → Event removed from list and database
- Expected: Events CRUD operations work end-to-end

**Edge cases**:
- Create event with minimum fields → Event saved with defaults
- Edit event with missing optional fields → Fields preserved or cleared as expected
- Upload multiple images for event → All images stored and thumbnails generated
- Expected: Edge cases handled gracefully

**Error cases**:
- Create event with invalid date (past date) → Error shown, event not created
- Upload oversized image → Error shown, upload cancelled
- Network error during event creation → Retry available, no duplicate creation
- Expected: Errors handled gracefully, user informed

**Integration points**:
- Create event → Appears in AllEventsPage with correct data
- Update event hero content → Landing page updates
- Delete event → Removed from all lists and collections

### Content Management (Team, Partners, Gallery, Settings)
**Happy path**:
- Create team member with photo → Appears on landing page
- Update partner info → Changes reflect in partnership section
- Add gallery photo → Appears in gallery and event association
- Update site settings → Changes used throughout application
- Expected: Content changes propagate to all pages

**Error cases**:
- Upload invalid image format → Error message, upload rejected
- Save settings with invalid email → Validation error shown
- Expected: Input validation prevents bad data

### Landing Page & Public Content
**Happy path**:
- Load landing page → Hero, featured events, team, partners display
- Filter events by date → Only matching events shown
- Search for event → Correct results appear
- Expected: Public pages render correctly with CMS data

**Edge cases**:
- Landing page with no featured event → Graceful fallback
- Events list with pagination → Navigation works correctly
- Event with no images → Placeholder used
- Expected: Graceful degradation for missing data

**Integration points**:
- Admin changes hero content → Landing page reflects changes
- Admin adds event → Event appears in all-events list
- Admin updates site settings → Footer contact info updates

### Form Management & Validation
**Happy path**:
- Submit valid event form → Event created, success toast shown
- Submit form with validation errors → Form doesn't submit, errors highlighted
- Expected: Form validation working as expected

**Error cases**:
- Server error during submission → Error toast shown, allow retry
- Network timeout → Appropriate error handling
- Expected: Graceful error recovery

## Test Generation Guidelines

**For Unit Tests:**
- Focus on utility functions (formatting, validation, API helpers)
- Test edge cases: empty strings, null values, boundary conditions
- Aim for pure functions with clear inputs/outputs
- Mock dependencies (API calls, database)
- Avoid testing React internals; focus on business logic

**For Integration Tests:**
- Test hooks with Supabase context
- Test ContentContext operations and state updates
- Test form submission end-to-end (from user input to state update)
- Test data flow between components
- Use actual Supabase test database or mock

**For E2E Tests (critical paths only):**
- Landing page loads and displays correct CMS data
- Admin can create an event and see it on landing page
- Admin can edit hero content and changes appear immediately
- User can filter and find events

**Testing Conventions:**
- Use descriptive test names: `should create event with all fields and display in list`
- Group related tests in describe blocks by feature
- Use setup/teardown for test isolation
- Test both success and error paths
- Avoid testing implementation details; test behavior

</test-strategy>

---

<architecture>

## System Components

**Frontend Application (React + TypeScript)**
- Browser-based single-page application
- Uses React Context for state management
- Custom client-side router for navigation
- Component-based architecture with separation of concerns

**UI Layer**
- Built on Radix UI primitives for accessibility
- Styled with Tailwind CSS for utility-first styling
- darkMode support via next-themes
- Responsive design for mobile, tablet, desktop

**Backend Services (Supabase)**
- PostgreSQL database for persistent storage
- Edge Functions (Hono) for serverless operations
- File storage for images and media
- Real-time subscriptions for collaborative features (future)

**Data Flow**
- User interactions → React Components → Hooks → ContentContext → Supabase Client → Database
- Admin edits → ContentContext → Supabase → Real-time → Landing page re-render

## Data Models

**Event**
```typescript
{
  id: string (UUID)
  title: string
  description: string
  date: Date
  time: string
  venue: string
  venue_address: string
  capacity: number
  price_min: number
  price_max: number
  category: 'festival' | 'art' | 'live_music' | 'club'
  status: 'draft' | 'upcoming' | 'ongoing' | 'completed' | 'archived'
  featured_image: string (URL)
  gallery_images: string[] (URLs)
  artists: Artist[]
  highlights: string[]
  created_at: timestamp
  updated_at: timestamp
}
```

**Team Member**
```typescript
{
  id: string (UUID)
  name: string
  role: string
  bio: string
  photo: string (URL)
  social_links: { platform: string, url: string }[]
  created_at: timestamp
  updated_at: timestamp
}
```

**Partner**
```typescript
{
  id: string (UUID)
  name: string
  category: 'music' | 'energy' | 'beverage' | 'lifestyle' | 'technology'
  logo: string (URL)
  website_url: string
  sponsorship_level: 'platinum' | 'gold' | 'silver' | 'bronze'
  created_at: timestamp
  updated_at: timestamp
}
```

**Gallery Item**
```typescript
{
  id: string (UUID)
  image_url: string
  caption: string
  event_id: string (FK)
  uploaded_at: timestamp
}
```

**Hero Content**
```typescript
{
  title: string
  subtitle: string
  featured_event_id: string (FK)
  background_image: string (URL)
  stats: { label: string, value: string }[]
}
```

**Site Settings**
```typescript
{
  contact_email: string
  contact_phone: string
  social_links: { platform: string, url: string }[]
  site_metadata: { key: string, value: string }[]
}
```

## Technology Stack

**Core Framework**
- **React 19.2.0** - UI library for component-based interfaces
- **TypeScript** - Type-safe JavaScript for better tooling and error prevention
- **Vite 7.2.1** - Fast build tool and dev server

**UI & Styling**
- **Tailwind CSS v4.1.3** - Utility-first CSS framework
- **Radix UI** - Unstyled, accessible component primitives
- **shadcn/ui** - Pre-built component patterns
- **Lucide React** - Icon library
- **Motion** - Animation library
- **next-themes** - Theme management (light/dark mode)

**State & Routing**
- **React Context API** - Global state management (no external libraries)
- **Custom Router** - Client-side routing with History API

**Backend & Database**
- **Supabase** - Backend-as-a-Service (PostgreSQL database, Edge Functions, Storage)
- **Hono** - Web framework for Edge Functions

**Forms & Input**
- **React Hook Form** - Form state management and validation
- **React Day Picker** - Date selection

**Notifications & UI Feedback**
- **Sonner** - Toast notifications library

**Data & Analytics**
- **Recharts** - Data visualization library

**Utilities**
- **CMDK** - Command menu component
- **Embla Carousel** - Carousel/slider component
- **Clsx** - Conditional CSS class names
- **Tailwind Merge** - Merge Tailwind classes

**Build & Configuration**
- **@vitejs/plugin-react-swc** - Fast React transformation with SWC
- **path aliases** - Use `@/` to reference `src/` directory

## Technology Decisions

**Decision: React + TypeScript over Vue/Svelte**
- **Rationale**: React ecosystem maturity, TypeScript first-class support, larger community resources
- **Trade-offs**: Larger bundle size than Vue, more verbose than Svelte
- **Alternatives considered**: Vue.js, Svelte

**Decision: Context API instead of Redux/Zustand**
- **Rationale**: Simpler setup for medium-complexity state, sufficient for current scope (5 main entities)
- **Trade-offs**: Manual memoization needed to prevent unnecessary renders
- **Alternatives considered**: Redux, Zustand, Recoil

**Decision: Custom Router instead of React Router**
- **Rationale**: Reduced dependencies, simple routing needs (3 main routes), control over implementation
- **Trade-offs**: No built-in features like nested routes, code splitting
- **Alternatives considered**: React Router, TanStack Router, TinyRouter

**Decision: Supabase for Backend**
- **Rationale**: PostgreSQL database, real-time capabilities, built-in auth, low operational overhead
- **Trade-offs**: Vendor lock-in, limited scalability options compared to self-hosted
- **Alternatives considered**: Firebase, self-hosted PostgreSQL, MongoDB

**Decision: Tailwind CSS + Radix UI**
- **Rationale**: Accessibility built-in (Radix), utility-first styling (Tailwind) reduces custom CSS, consistent design system
- **Trade-offs**: Large CSS file (mitigated by Vite purging), learning curve for utility-first
- **Alternatives considered**: Material UI, Ant Design, custom CSS

**Decision: React Hook Form over Formik**
- **Rationale**: Smaller bundle size, performance optimized, minimal re-renders
- **Trade-offs**: Less out-of-the-box validation compared to Formik
- **Alternatives considered**: Formik, Final Form

</architecture>

---

<risks>

## Technical Risks

**Risk**: Supabase Real-time subscriptions not scaling beyond 50K members
- **Impact**: High - Platform can't handle live updates as community grows
- **Likelihood**: Medium - Known limitation of real-time services
- **Mitigation**: Implement smart subscription management (only subscribe to events user is interested in), use polling fallback
- **Fallback**: Migrate to self-hosted PostgreSQL with custom WebSocket layer

**Risk**: React Context re-renders on every content change, performance degrades
- **Impact**: Medium - UI becomes sluggish as data grows
- **Likelihood**: Medium - Context doesn't have built-in memoization
- **Mitigation**: Implement useMemo/useCallback in context, consider split contexts per entity, add performance monitoring
- **Fallback**: Migrate to Zustand or Redux for fine-grained reactivity

**Risk**: Image uploads to Supabase Storage overwhelm performance or costs
- **Impact**: Medium - Platform degrades under high upload volume
- **Likelihood**: Low - Supabase Storage is production-grade
- **Mitigation**: Implement image compression before upload, add CDN for image delivery, set storage quotas
- **Fallback**: Use alternative storage (AWS S3, Cloudinary)

**Risk**: TypeScript type definitions become unmaintainable as schema evolves
- **Impact**: Low-Medium - Bugs due to type mismatch
- **Likelihood**: Medium - Schema changes without type updates
- **Mitigation**: Use Supabase type generation tools, automate schema → types pipeline, enforce type-only imports
- **Fallback**: Accept runtime validation, add zod/runtime type checking

## Dependency Risks

**Risk**: Radix UI or Tailwind CSS breaking changes in major version bumps
- **Impact**: Medium - May require component rewrites
- **Likelihood**: Low - Mature libraries with stable APIs
- **Mitigation**: Pin versions in package.json, test major version upgrades in staging first
- **Fallback**: Fork and patch libraries if critical issues arise

**Risk**: Supabase service outage affects admin dashboard availability
- **Impact**: High - Admins can't manage content during outage
- **Likelihood**: Low - SLA usually 99.5%+
- **Mitigation**: Implement offline mode with local storage backup, cache admin data client-side
- **Fallback**: Accept downtime, set up monitoring/alerts

**Risk**: Node/npm ecosystem breaking changes (Vite, TypeScript, etc.)
- **Impact**: Medium - Build may fail, compatibility issues
- **Likelihood**: Low - Conservative upgrade strategy
- **Mitigation**: Regular dependency updates in isolation, test in CI, use lockfile (package-lock.json)
- **Fallback**: Rollback to known-good versions

## Scope Risks

**Risk**: Event schema requirements evolve faster than implementation
- **Impact**: Medium - Mid-development schema changes, rework required
- **Likelihood**: High - Evolving requirements typical in startups
- **Mitigation**: Build flexible schema with JSONB fields, design for extension, frequent stakeholder reviews
- **Fallback**: Prioritize core MVP, defer non-essential fields to Phase 2

**Risk**: UI/UX requirements expand beyond initial scope (animations, complex interactions)
- **Impact**: Low-Medium - Timeline slips, scope creep
- **Likelihood**: Medium - Designer may add polish iteratively
- **Mitigation**: Lock scope before Phase 3, use design system to standardize, time-box polish work
- **Fallback**: Release v0.1.0 with basic UX, refine in v0.2.0

**Risk**: Team capacity lower than estimated (1-2 developers instead of 3)
- **Impact**: High - Timeline extends significantly
- **Likelihood**: Medium - Startup resource constraints
- **Mitigation**: Prioritize MVP features (Phases 0-5), defer nice-to-have (Phase 7-8)
- **Fallback**: Cut less critical features (analytics, monitoring), extend timeline

**Risk**: Unclear requirements for admin workflows
- **Impact**: Medium - Built features don't match admin needs
- **Likelihood**: Medium - First-time admin tool
- **Mitigation**: Conduct admin interviews, build mock screens, iterate on DashboardLayout before full implementation
- **Fallback**: Be ready to redesign admin UI in Phase 4 before full implementation

</risks>

---

<appendix>

## References

- **Supabase Documentation**: https://supabase.com/docs
- **React Documentation**: https://react.dev
- **TypeScript Handbook**: https://www.typescriptlang.org/docs/
- **Tailwind CSS**: https://tailwindcss.com/docs
- **Radix UI**: https://www.radix-ui.com/primitives/docs/overview/introduction
- **Vite Documentation**: https://vitejs.dev/guide/
- **RPG Methodology**: https://www.microsoft.com/en-us/research/publication/the-repository-planning-graph-rpg-method/ (reference)
- **WildOut! Figma Design**: https://www.figma.com/design/gdU03sBHxmwEdKKZb5eJHW/WildOut--Landing-Page-and-Dashboard

## Glossary

- **CMS**: Content Management System - admin interface for managing events, team, partners, gallery, and settings
- **CRUD**: Create, Read, Update, Delete - basic operations on data entities
- **Context API**: React's built-in state management mechanism
- **Hook**: Reusable function in React for state and effects
- **Supabase**: Backend-as-a-Service combining PostgreSQL, authentication, storage, and edge functions
- **Edge Function**: Serverless function running on Supabase infrastructure
- **Radix UI**: Low-level component library providing accessibility and unstyled primitives
- **Tailwind CSS**: Utility-first CSS framework
- **Entity**: A domain object (Event, Team, Partner, etc.)
- **Payload**: Data sent to or received from an API
- **Topological Order**: Ordering dependencies such that all dependencies of an item come before the item

## Open Questions

1. **Admin Authentication**: How should admin users authenticate? (OAuth, email/password, SAML?)
2. **Event Artist Data Model**: Should artists be standalone entities or always linked to events?
3. **Community Profiles**: Should artists/venues have public profiles with their own pages?
4. **Analytics Requirements**: What specific metrics should dashboard show? (views, clicks, conversions?)
5. **Multi-language Support**: Should platform support Indonesian + English from start?
6. **Payment Integration**: Is there an event ticketing/payment flow needed?
7. **Image Storage Strategy**: CDN requirement? Image optimization preferences?
8. **Real-time Requirements**: Do admins need to see real-time collaborative editing or is eventual consistency OK?
9. **Mobile Admin App**: Is mobile admin dashboard needed or web-only?
10. **Version History**: Should content have revision history/rollback capabilities?

</appendix>

---

<task-master-integration>

# How Task Master Uses This PRD

When you run `task-master parse-prd <file>.txt`, the parser:

1. **Extracts capabilities** → Main tasks
   - Each `### Capability:` becomes a top-level task

2. **Extracts features** → Subtasks
   - Each `#### Feature:` becomes a subtask under its capability

3. **Parses dependencies** → Task dependencies
   - `Depends on: [X, Y]` sets task.dependencies = ["X", "Y"]

4. **Orders by phases** → Task priorities
   - Phase 0 tasks = highest priority
   - Phase N tasks = lower priority, properly sequenced

5. **Uses test strategy** → Test generation context
   - Feeds test scenarios to Surgical Test Generator during implementation

**Result**: A dependency-aware task graph that can be executed in topological order.

## Why RPG Structure Matters

Traditional flat PRDs lead to:
- ❌ Unclear task dependencies
- ❌ Arbitrary task ordering
- ❌ Circular dependencies discovered late
- ❌ Poorly scoped tasks

RPG-structured PRDs provide:
- ✅ Explicit dependency chains
- ✅ Topological execution order
- ✅ Clear module boundaries
- ✅ Validated task graph before implementation

## Tips for Best Results

1. **Spend time on dependency graph** - This is the most valuable section for Task Master
2. **Keep features atomic** - Each feature should be independently testable
3. **Progressive refinement** - Start broad, use `task-master expand` to break down complex tasks
4. **Use research mode** - `task-master parse-prd --research` leverages AI for better task generation

</task-master-integration>
