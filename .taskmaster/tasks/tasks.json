{
  "master": {
    "tasks": [
      {
        "id": 13,
        "title": "Setup Foundational TypeScript Types",
        "description": "Define all global TypeScript types for domain entities like Event, Team Member, Partner, etc., to ensure type safety across the application. These will serve as the single source of truth for data structures.",
        "details": "Create type definition files under `src/types/`. Define interfaces for `Event`, `TeamMember`, `Partner`, `GalleryItem`, `HeroContent`, and `SiteSettings` as specified in the PRD's data models. A key step is to generate types from the Supabase schema to ensure alignment. Use the Supabase CLI: `npx supabase gen types typescript --project-id <YOUR_PROJECT_ID> > src/supabase/types.ts`. Then, import these generated types into your main type definition files to build upon them.",
        "testStrategy": "Validate by running the TypeScript compiler (`npx tsc --noEmit`) across the project. Success is defined as zero type errors. Also, verify that IDE IntelliSense correctly provides autocompletion for all defined types when used in other files.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Finalize Tailwind CSS v4 and Shadcn/ui Configuration",
        "description": "Finalize the configuration of Tailwind CSS v4 and its integration with Shadcn/ui. This involves adding the Vite plugin, creating the Tailwind theme configuration, refining global CSS variables, and creating the class-merging utility.",
        "details": "The project has a partial Tailwind v4 setup. This task is to complete it.\n1. Add the `@tailwindcss/vite` plugin to `vite.config.ts`.\n2. Create/update `tailwind.config.ts` with the shadcn/ui theme configuration (container, colors, radius, keyframes) and the `tailwindcss-animate` plugin. Ensure `darkMode: 'class'` is set.\n3. Refine `src/styles/globals.css` to define the complete set of CSS variables for light and dark themes as required by shadcn/ui.\n4. Create the `cn` utility function in `src/lib/utils.ts` using the already installed `clsx` and `tailwind-merge` packages.\n5. Ensure `src/index.css` is imported in `src/main.tsx` to apply styles globally.",
        "testStrategy": "Apply Tailwind utility classes to a test component in `App.tsx`. Verify styles are applied correctly. Use the `cn` utility to conditionally apply classes and check the output. Manually toggle the 'dark' class on the `<html>` element in the browser's dev tools to confirm dark mode styles defined in `globals.css` work as expected. Ensure the build process purges unused CSS.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1401,
            "title": "Configure Vite with TailwindCSS Plugin",
            "description": "Update the `vite.config.ts` file to import and use the `@tailwindcss/vite` plugin.",
            "dependencies": [],
            "details": "Import `tailwindcss` from `@tailwindcss/vite` and add it to the `plugins` array in the `defineConfig` call within `vite.config.ts`. This enables Tailwind to process styles during development and build.",
            "status": "pending",
            "testStrategy": "Run the Vite development server. Check for any console errors related to Tailwind CSS. A successful start indicates the plugin is loaded correctly."
          },
          {
            "id": 1402,
            "title": "Create and Configure tailwind.config.ts for Shadcn",
            "description": "Create the `tailwind.config.ts` file and populate it with the theme required by shadcn/ui.",
            "dependencies": [],
            "details": "Create `tailwind.config.ts` at the project root. Configure the `content` array to scan `src/**/*.{ts,tsx}` files. Set `darkMode: 'class'`. Inside the `theme` object, configure `container`, `extend` `colors`, `borderRadius`, `keyframes`, and `animation` with the values provided by the shadcn/ui documentation. Add the `tailwindcss-animate` plugin to the `plugins` array.",
            "status": "pending",
            "testStrategy": "After configuration, apply a custom color (e.g., `bg-primary`) to an element. Verify in the browser that the correct hex code is applied."
          },
          {
            "id": 1403,
            "title": "Refine and Finalize globals.css",
            "description": "Update the existing `src/styles/globals.css` to include all necessary base styles, layers, and CSS variables for the shadcn/ui theme.",
            "dependencies": [
              1402
            ],
            "details": "In `src/styles/globals.css`, ensure the `@tailwind` directives for `base`, `components`, and `utilities` are present. Below these, define the full set of CSS variables for colors, radius, etc., within `@layer base`. Define separate variable sets for the root `:root` (light theme) and `.dark` selectors.",
            "status": "pending",
            "testStrategy": "Inspect the `<html>` element in the browser. Verify all CSS variables (`--background`, `--foreground`, etc.) are defined. Toggle the `.dark` class on the `<html>` element and verify the CSS variable values update."
          },
          {
            "id": 1404,
            "title": "Create cn() Class-Merging Utility",
            "description": "Create a `cn.ts` utility file that exports a function for safely merging Tailwind CSS classes.",
            "dependencies": [],
            "details": "Create a file at `src/lib/utils.ts`. Import `clsx` and `tailwind-merge`. Export a function `cn` that takes `...inputs: ClassValue[]` and returns `twMerge(clsx(inputs))`. This utility is essential for building components with variant styles.",
            "status": "pending",
            "testStrategy": "Create a test case, either manually or with Vitest, that calls `cn('p-4', 'p-2')` and asserts that the result is `'p-2'`, demonstrating the merging logic."
          }
        ]
      },
      {
        "id": 15,
        "title": "Initialize Supabase Client Configuration",
        "description": "Set up and configure the Supabase JavaScript client to enable communication with the Supabase backend for database operations, authentication, and storage.",
        "details": "Install the Supabase client library: `npm install @supabase/supabase-js`. Create a file at `src/supabase/client.ts`. Initialize the client using `createClient` from `@supabase/supabase-js`. Store your Supabase URL and anon key in `.env.local` as `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` and access them via `import.meta.env`. Export a single, memoized instance of the client.",
        "testStrategy": "Write a small test script or a temporary component that attempts to fetch a simple list (e.g., `supabase.from('some_table').select('*')`). A successful connection without authentication or RLS errors confirms the setup is correct. Ensure environment variables are not exposed in the client-side bundle.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Create Core Utility Functions Module",
        "description": "Develop a set of common, reusable utility functions for tasks like date formatting, string manipulation, and input validation, to be used throughout the application.",
        "details": "Create files under `src/utils/`, such as `formatting.ts` and `validation.ts`. For `formatting.ts`, add functions like `formatDate(date)` and `formatCurrency(amount)`. For `validation.ts`, create functions like `isValidEmail(email)`. The `cn` utility for class names is handled in the Tailwind setup task (Task 14).",
        "testStrategy": "Implement unit tests for each utility function using a framework like Vitest. Test for expected outputs with valid inputs, and test edge cases like null, undefined, or malformed inputs to ensure they are handled gracefully without crashing.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Add Core shadcn/ui Components",
        "description": "With shadcn/ui initialized, add the first set of core, reusable UI components like Button, Input, and Dialog, which will form the building blocks of the UI.",
        "details": "Confirm that the shadcn/ui `components.json` is correctly configured. Then, use the CLI to add the essential primitives: `npx shadcn-ui@latest add button input label dialog card`. Verify the new components are created in the `src/components/ui` directory.",
        "testStrategy": "For each component, create a story in Storybook or render it on a test page. Verify that it renders correctly, handles user interactions (e.g., clicks, typing), and is fully accessible according to ARIA standards. Check responsiveness on different screen sizes.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Toast Notifications with Sonner",
        "description": "Integrate the Sonner library to provide non-blocking toast notifications for user feedback on actions like success, error, or information.",
        "details": "Install the library: `npm install sonner`. Add the `<Toaster />` component to the root of your application layout (`App.tsx` or `DashboardLayout.tsx`). Use the `toast()` function exported from `sonner` to trigger notifications from anywhere in the app, for example: `toast.success('Event created successfully!')`.",
        "testStrategy": "Create temporary buttons in the UI to trigger different types of toasts (success, error, info, promise). Verify that they appear correctly, are styled as expected, and disappear automatically or can be dismissed by the user.",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Form Management with React Hook Form",
        "description": "Integrate React Hook Form and create reusable form components for handling complex form state, validation, and submission efficiently.",
        "details": "Install dependencies: `npm install react-hook-form @hookform/resolvers zod`. Create a generic `<Form />` component using `shadcn/ui`'s form components which are built on `react-hook-form`. Use `zod` to define validation schemas that align with your TypeScript types. Use the `@hookform/resolvers/zod` adapter to connect Zod schemas to your forms for real-time validation.",
        "testStrategy": "Build a sample form with various input types (text, select, checkbox). Test the happy path: valid submission. Test validation: ensure error messages appear for invalid fields and submission is blocked. Test that the form state is reset correctly after submission.",
        "priority": "high",
        "dependencies": [
          13,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Custom Client-Side Router",
        "description": "Develop a lightweight, custom client-side router using React Context and the browser's History API to manage navigation between the landing page, all-events page, and admin dashboard.",
        "details": "Create `src/components/Router.tsx`. Implement a `RouterProvider` that uses `React.createContext` to provide the current path and a `navigate` function. Use `useState` to hold the current path, initialized from `window.location.pathname`. Use a `useEffect` hook to listen to the `popstate` event to handle browser back/forward buttons. The `navigate` function should use `window.history.pushState` and update the internal state.",
        "testStrategy": "Wrap the main `App.tsx` with the `RouterProvider`. Create navigation links and test that clicking them updates the URL in the browser bar and renders the correct page component without a full page reload. Test that the browser's back and forward buttons work as expected.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Global ContentContext for State Management",
        "description": "Create a global React Context to manage the state of all primary content entities (events, team, partners, etc.), providing a centralized place for data fetching, caching, and mutations.",
        "details": "Create `src/contexts/ContentContext.tsx`. The context provider will manage state for `events`, `team`, `partners`, `gallery`, etc., along with their `loading` and `error` states. It will expose functions like `fetchEvents()`, `addEvent(newEvent)`, `updateEvent(id, data)`, etc. These functions will interact with the Supabase client and update the context state, acting as a simple client-side cache.",
        "testStrategy": "Write unit tests for the context's reducer or state update logic. Create a test component that consumes the context, calls a fetch function, and verifies that the `loading` state changes correctly and the final data is populated. Mock the Supabase client to isolate the context logic.",
        "priority": "high",
        "dependencies": [
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Develop Custom Hooks for Business Logic",
        "description": "Create custom hooks like `useEvents` and `useRouter` to abstract away business logic and interactions with context, simplifying component code.",
        "details": "Create files in `src/hooks/`. The `useRouter` hook will simply be `return useContext(RouterContext)`. The `useEvents` hook will consume the `ContentContext` and return the `events` state, loading/error status, and the event-specific functions (`addEvent`, `updateEvent`, etc.). This encapsulates the logic for interacting with the global state.",
        "testStrategy": "Test the hooks within components. For `useEvents`, verify that a component using it re-renders when the event data changes in the `ContentContext`. For `useRouter`, verify it provides the correct navigation functions and current path.",
        "priority": "medium",
        "dependencies": [
          20,
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Admin Authentication Flow",
        "description": "Set up a secure authentication mechanism for the admin dashboard using Supabase Auth, including login, session management, and protected routes.",
        "details": "Utilize Supabase Auth with the email/password or magic link provider. Create a login page for the admin dashboard. On successful login, Supabase's client handles the session. Create a protected route component that checks for an active user session (`supabase.auth.getSession()`). If no session exists, it redirects to the login page. The admin dashboard will be wrapped in this protected route.",
        "testStrategy": "Manually test the auth flow. 1) Attempt to access an admin URL directly and verify redirection to the login page. 2) Log in with valid credentials and verify access is granted. 3) Log out and verify session is terminated and user is redirected. 4) Check for the `sb-` auth token in browser storage.",
        "priority": "high",
        "dependencies": [
          15,
          18,
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Build Responsive DashboardLayout Component",
        "description": "Create the main layout for the admin dashboard, including a persistent sidebar for navigation, a header, and a main content area for dashboard pages.",
        "details": "Create `src/components/dashboard/DashboardLayout.tsx`. This component will render a sidebar with navigation links (using Lucide icons and `NavLink`-style components) to the different admin sections (Events, Team, etc.). Use CSS Grid or Flexbox to create a responsive layout that collapses the sidebar into a menu on smaller screens. The layout will render `{children}` in the main content area.",
        "testStrategy": "Wrap a sample dashboard page within the `DashboardLayout`. Verify that the layout is responsive by resizing the browser window. Test navigation by clicking sidebar links, ensuring the correct page content is loaded without the layout itself re-rendering unnecessarily.",
        "priority": "high",
        "dependencies": [
          17,
          20,
          22
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Dashboard Home Page with Statistics",
        "description": "Develop the main landing page of the admin dashboard, displaying key overview statistics and quick links to management sections.",
        "details": "Create `src/components/dashboard/DashboardHome.tsx`. This component will use the `useContent` hook to fetch summary data, such as the total number of upcoming events, total team members, and total partners. Display these stats using the `Card` component. Use a library like `Recharts` to add a simple bar chart showing events per month.",
        "testStrategy": "Verify that the dashboard home page correctly displays statistics pulled from the `ContentContext`. Manually add data to the database and refresh the page to ensure the stats update accordingly. Check that the chart renders correctly with sample data.",
        "priority": "medium",
        "dependencies": [
          21,
          22,
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Build Dashboard Event List Page",
        "description": "Create the UI for listing all events in the admin dashboard, with features for sorting, filtering, and pagination.",
        "details": "Create `src/components/dashboard/DashboardEvents.tsx`. Use the `useEvents` hook to get the list of events. Render the events in a `Table` component from `shadcn/ui`. Add controls (Input, Select) for filtering by status or searching by title. Implement client-side or server-side pagination to handle a large number of events.",
        "testStrategy": "Populate the database with a variety of events (different statuses, dates). Verify the table displays all events correctly. Test the search and filter functionality to ensure the list updates as expected. Test pagination by navigating between pages.",
        "priority": "medium",
        "dependencies": [
          22,
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Build Event Create/Edit Form and Logic",
        "description": "Implement the form for creating and editing events, including all metadata fields, validation, and submission logic to persist the data via Supabase.",
        "details": "Create `src/components/dashboard/DashboardEventsNew.tsx`. Use `react-hook-form` and a `zod` schema for validation. The form should include fields for all properties in the `Event` type, using `shadcn/ui` components like `Input`, `Textarea`, and `ReactDayPicker` for dates. The `onSubmit` handler will call the `addEvent` or `updateEvent` function from the `ContentContext` and show a success/error toast.",
        "testStrategy": "Happy path: Create a new event, fill all fields, submit, and verify it appears in the event list (Task 26) and the database. Edit an existing event and verify changes are saved. Error path: Try to submit the form with invalid data and verify that validation errors are displayed and submission is blocked.",
        "priority": "high",
        "dependencies": [
          18,
          19,
          21,
          26
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement Image Upload to Supabase Storage",
        "description": "Develop the functionality for uploading images (e.g., event featured image, team member photos) to Supabase Storage and linking the URL to the corresponding database record.",
        "details": "Integrate an image upload component into the relevant forms (e.g., Event form). Use an `<input type='file' />`. On file selection, use a library like `browser-image-compression` to resize and compress the image client-side. Then, use `supabase.storage.from('images').upload(filePath, file)` to upload it. Once the upload is complete, retrieve the public URL using `supabase.storage.from('images').getPublicUrl(filePath)` and save this URL in the appropriate database field.",
        "testStrategy": "In the event creation form, upload an image. Verify the image appears in your Supabase Storage bucket. Verify the event record in the database contains the correct public URL for the image. Check that the image loads correctly on the public-facing pages.",
        "priority": "medium",
        "dependencies": [
          15,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Build Team Member Management Page",
        "description": "Create the admin interface for CRUD operations on team members, including their name, role, bio, and photo.",
        "details": "Create `src/components/dashboard/DashboardTeam.tsx`. This will be similar in structure to the event management page. It will list existing team members and have a button to open a Dialog/Modal containing the form for adding/editing a member. The form will use `react-hook-form` and include an image uploader (reusing logic from Task 28).",
        "testStrategy": "Perform full CRUD tests: Create a new team member and verify they appear in the list. Update their details and photo, and confirm the changes. Delete the team member and ensure they are removed from the list and the database.",
        "priority": "medium",
        "dependencies": [
          24,
          27,
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Build Partner/Sponsor Management Page",
        "description": "Implement the admin interface for managing partners and sponsors, including their name, category, logo, and website URL.",
        "details": "Create `src/components/dashboard/DashboardPartners.tsx`. Follow the same pattern as Team Management (Task 29). It will feature a list of partners and a form (in a modal) for CRUD operations. The form will include fields for partner details and a logo uploader.",
        "testStrategy": "Perform full CRUD tests for partners. Verify that creating, updating, and deleting partners works correctly and that the data is accurately reflected in the database. Ensure partner logos can be uploaded and displayed.",
        "priority": "medium",
        "dependencies": [
          24,
          27,
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Build Landing Page Content Management (Hero & About)",
        "description": "Create admin interfaces for managing the content of the landing page's Hero and About sections.",
        "details": "Create `DashboardHero.tsx` and `DashboardAbout.tsx`. These will be simple forms that fetch the current content from the `ContentContext`. The forms will allow admins to update fields like the hero title, subtitle, featured event ID (using a select dropdown of events), and the about section text. On save, the `updateHeroContent` function in the context is called.",
        "testStrategy": "Load the admin pages and verify they are pre-populated with the current content. Make a change (e.g., update the hero title), save it, and then load the public-facing landing page to confirm the change is immediately visible.",
        "priority": "medium",
        "dependencies": [
          24,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Build Site Settings Management Page",
        "description": "Develop the admin page for managing global site settings, such as contact information and social media links.",
        "details": "Create `src/components/dashboard/DashboardSettings.tsx`. This will be a single form that loads the global `site_settings` object from the `ContentContext`. It will allow admins to edit the contact email, phone number, and social media URLs. On save, it updates the single settings record in the database.",
        "testStrategy": "Change a social media link in the settings form and save. Navigate to the public site's footer and verify that the link has been updated. This confirms the end-to-end flow from admin input to public display.",
        "priority": "medium",
        "dependencies": [
          24,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Build and Compose the Public Landing Page",
        "description": "Assemble the main public-facing landing page by composing various sections like Hero, Featured Events, Team, and Partners, pulling all data from the ContentContext.",
        "details": "Create `src/components/LandingPage.tsx`. This component will be the main entry point for the public site. It will use the `useContent` hook to access all necessary data. It will then render individual section components (e.g., `<HeroSection />`, `<FeaturedEventsSection />`, `<TeamSection />`, `<PartnersSection />`, `<Footer />`), passing the relevant data down as props.",
        "testStrategy": "Load the landing page and verify that all sections are rendered with the correct data from the CMS. Ensure the page is fully responsive and visually matches the Figma designs. Check that all links (e.g., to social media) are correct.",
        "priority": "high",
        "dependencies": [
          21,
          22,
          29,
          30,
          31,
          32
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Build 'All Events' Page with Filtering and Search",
        "description": "Create a dedicated page for users to browse, search, and filter all available events, with support for pagination.",
        "details": "Create `src/components/AllEventsPage.tsx`. The page will fetch all 'upcoming' events from the `ContentContext`. Implement UI controls (`Input`, `Select`, `Checkbox`) for filtering by category, date range, and a text-based search. The filtering logic can be implemented client-side for now. Render the filtered results as a grid of `EventCard` components. Add a pagination component to navigate through a large list.",
        "testStrategy": "With a large set of test events, verify that the initial list loads. Test each filter individually and in combination to ensure the event list updates correctly. Test the search functionality. Test the pagination to make sure you can navigate through all results.",
        "priority": "medium",
        "dependencies": [
          22,
          33
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implement Event Detail View/Modal",
        "description": "Create a detailed view for a single event, showing all information including the gallery, artist lineup, and venue details. This can be a modal or a separate page.",
        "details": "When a user clicks on an `EventCard` (from Task 33 or 34), open a `Dialog` modal. The modal will receive the `eventId` as a prop. It will then fetch the full event details from the `ContentContext`. The view will display all event fields, including a carousel (`Embla Carousel`) for the image gallery and a list of associated artists.",
        "testStrategy": "Click on various event cards from the landing page and the 'All Events' page. Verify that the correct event's details are loaded and displayed in the modal. Check that the image gallery is functional. Ensure the modal can be closed properly.",
        "priority": "medium",
        "dependencies": [
          33,
          34
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement Client-Side Caching Strategy",
        "description": "Optimize performance by enhancing the ContentContext to act as a more robust client-side cache, reducing redundant API calls to Supabase.",
        "details": "Refine the `ContentContext`. When a fetch function (e.g., `fetchEvents`) is called, first check if the data already exists in the context's state and is not stale. If it is, return the cached data. If not, fetch from Supabase and update the state. The mutation functions (`addEvent`, `updateEvent`) must invalidate the cache by either refetching the data or intelligently updating the local state.",
        "testStrategy": "Using browser dev tools, monitor network requests. Navigate between pages that use the same data (e.g., from landing page to all events page). Verify that the data is fetched only once initially, and subsequent navigations use the cached data from the context, resulting in no new network requests for that data.",
        "priority": "low",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Setup E2E Testing for Critical User Journeys",
        "description": "Establish an end-to-end testing suite using a framework like Playwright or Cypress to automate testing of critical user paths, such as admin event creation and public event discovery.",
        "details": "Install Playwright: `npm init playwright@latest`. Create test files in the `tests` directory. Write scripts for the following scenarios: 1) Admin logs in, creates a new event, and saves it. 2) A public user visits the site, sees the new event on the landing page, navigates to the all-events page, filters for it, and opens its detail view. Configure the tests to run against a seeded test database.",
        "testStrategy": "Run the E2E test suite via the command line (`npx playwright test`). The tests should pass consistently in a headless browser. Integrate this command into a CI/CD pipeline (e.g., GitHub Actions) to run automatically on every push or pull request to the main branch, preventing regressions.",
        "priority": "low",
        "dependencies": [
          23,
          27,
          35
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-07T06:02:41.440Z",
      "updated": "2025-11-24T12:35:27.293Z",
      "description": "Tasks for master context"
    }
  }
}