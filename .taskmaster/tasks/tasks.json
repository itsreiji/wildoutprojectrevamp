{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Foundation: Setup TypeScript Types and Utility Functions",
        "description": "Successfully established the foundational TypeScript types for all data models (Event, TeamMember, Partner, etc.) and created a library of shared utility functions. This work, guided by the `foundation-types-utils` OpenSpec, provides a strongly-typed foundation for the application's data layer.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "## OpenSpec Proposal\n- **Proposal ID**: `foundation-types-utils`\n- **Status**: approved\n- **Location**: `openspec/changes/foundation-types-utils/`\n\nThe implementation followed the specifications in this proposal, and the checklist in `tasks.md` is now complete.\n\n---\n\n### Implementation Summary\n\nAll type definitions and utility functions have been implemented as specified:\n\n- **Type Definitions**: All data model interfaces are defined in `src/types/`, including `events.ts`, `team.ts`, `partners.ts`, `content.ts`, and `settings.ts`.\n\n- **Utility Functions**: Helper functions for formatting (`src/utils/formatting.ts`), validation (`src/utils/validation.ts`), and API interactions with Supabase (`src/utils/api.ts`) have been created.\n\n- **Integration**: The `ContentContext` in `src/contexts/ContentContext.tsx` has been successfully updated to import and use these new types, ensuring type-safe state management across the application.",
        "testStrategy": "All types were confirmed to compile without errors using `tsc --noEmit`. Unit tests were written for all utility functions in `src/utils/` using Vitest, covering all specified edge cases. All tests are passing, validating the implementation against the criteria in `openspec/changes/foundation-types-utils/tasks.md`.",
        "subtasks": [
          {
            "id": 1,
            "title": "Review and Finalize OpenSpec Proposal",
            "description": "Review the draft OpenSpec proposal to ensure it aligns with project goals and technical requirements before starting implementation. This step is crucial to formalize the plan.",
            "dependencies": [],
            "details": "Locate the proposal in `openspec/changes/foundation-types-utils/`. Review the type definitions, utility function signatures, and the implementation checklist in `tasks.md`. Provide feedback and get approval to move the proposal from `draft` to `approved` status.",
            "status": "done",
            "testStrategy": "Confirmation of review and approval from the project lead. The spec's status should be updated to 'approved' before subsequent tasks begin.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Directory Structure and Core Event Type Definition",
            "description": "Establish the foundational directory structure and implement the `Event` type, which is central to the application, according to the approved specification.",
            "dependencies": [
              1
            ],
            "details": "Create the `src/types` and `src/utils` directories if they don't already exist. Then, create the file `src/types/events.ts` and implement the `Event` TypeScript interface precisely as specified in the `foundation-types-utils` OpenSpec.",
            "status": "done",
            "testStrategy": "Run `tsc --noEmit` to ensure the new type file compiles correctly without errors. No runtime tests are needed for this structure and type definition task.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define Team Member and Partner TypeScript Interfaces",
            "description": "Expand the application's data models by defining the TypeScript interfaces for `TeamMember` and `Partner` based on the approved OpenSpec.",
            "dependencies": [
              2
            ],
            "details": "In the `src/types` directory, create `team.ts` and `partners.ts`. Implement the `TeamMember` and `Partner` interfaces exactly as defined in the `foundation-types-utils` OpenSpec to ensure consistency with the data schema.",
            "status": "done",
            "testStrategy": "Verify type correctness by running `tsc --noEmit`. Ensure all defined interfaces are exported correctly from their respective modules as per the spec.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Define Interfaces for General Page Content and Settings",
            "description": "Create TypeScript types for singleton content pieces and global settings, following the data models specified in the OpenSpec.",
            "dependencies": [
              2
            ],
            "details": "Create `src/types/content.ts` and `src/types/settings.ts`. Implement the `HeroContent`, `AboutContent`, `GalleryImage`, and `Settings` interfaces as detailed in the approved `foundation-types-utils` OpenSpec.",
            "status": "done",
            "testStrategy": "Compile the project using `tsc --noEmit` to check for any syntax or type-related errors in the newly created definition files.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Formatting and Validation Utility Functions",
            "description": "Create a set of reusable utility functions for common data manipulation tasks, as specified in the OpenSpec, to ensure consistency across the application.",
            "dependencies": [
              1
            ],
            "details": "In `src/utils`, create `formatting.ts` and `validation.ts`. Implement the utility functions (`formatDate`, `isValidUrl`, etc.) according to the specification in the `foundation-types-utils` OpenSpec. The spec may recommend libraries like `zod` for more complex schema validation.",
            "status": "done",
            "testStrategy": "Write unit tests for each utility function using Vitest. Test `formatDate` with various date objects and edge cases. For validation functions, test with both valid and invalid inputs to ensure correctness, following the checklist in `tasks.md`.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create Initial API Helper Functions for Supabase",
            "description": "Establish a centralized API layer by creating an `api.ts` file containing typed functions for interacting with the Supabase backend, as laid out in the OpenSpec.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create `src/utils/api.ts`. Following the OpenSpec, import the newly created data model types and define async helper functions (`getEvents`, `getTeamMembers`, etc.) that will wrap Supabase calls. Ensure function signatures match the spec.",
            "status": "done",
            "testStrategy": "Since the Supabase client may not yet be implemented, this task can be tested by ensuring the file compiles without errors (`tsc --noEmit`) and that the function signatures correctly use the TypeScript types defined in previous tasks.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Conduct Final Code Review and Merge",
            "description": "Review the completed implementation of all types and utilities to ensure it meets code quality standards and correctly follows the OpenSpec proposal before merging.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Perform a thorough code review of the changes in the relevant feature branch. Check for adherence to the coding style, correctness of the TypeScript types, and the implementation of utility functions. Verify that the integration with `ContentContext.tsx` is correct. Once approved, merge the branch into main.",
            "status": "done",
            "testStrategy": "Approval from at least one other project lead. Successful merge of the feature branch into the main development branch without conflicts.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Based on the provided subtasks, generate detailed implementation steps for each. For type definitions, ensure all fields from the PRD's data models are included. For utility functions, provide code examples for date formatting, email validation, and a placeholder for an API helper function that fetches events."
      },
      {
        "id": 2,
        "title": "Configuration: Initialize and Configure Supabase Client",
        "description": "The Supabase client instance has been successfully configured by refactoring hardcoded credentials into environment variables. Database types were generated from the schema, ensuring end-to-end type safety. This work was completed according to the OpenSpec proposal `supabase-client-config`.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "## OpenSpec Proposal\n- **Proposal ID**: `supabase-client-config`\n- **Status**: implemented\n- **Location**: `openspec/changes/supabase-client-config/`\n\nThe implementation is complete and matches the OpenSpec specification. Hardcoded credentials have been removed and replaced with a typed, singleton client that reads its configuration from Vite environment variables.\n\n### Implementation Summary\n- **Client File**: A singleton Supabase client was created in `src/supabase/client.ts` using `createClient` from `@jsr/supabase__supabase-js`.\n- **Environment Variables**: The client is configured using `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` from the `.env` file, with runtime checks to ensure they are present.\n- **Type Safety**: Database types were generated via the Supabase CLI into `src/supabase/types.ts`, providing a strongly-typed `Database` interface for the client. This includes types for all 10 discovered tables (settings, partners, teams, etc.).\n- **Backward Compatibility**: The old configuration file, `src/utils/supabase/info.tsx`, was not deleted. It was updated to re-export the new client, acting as a compatibility layer to prevent breaking existing imports.\n\n```typescript\n// src/supabase/client.ts (Final Implementation)\nimport { createClient } from '@jsr/supabase__supabase-js';\nimport type { Database } from './types';\n\nconst supabaseUrl = import.meta.env.VITE_SUPABASE_URL;\nconst supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Supabase URL and anon key are required.');\n}\n\nexport const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey);\n```",
        "testStrategy": "The new `supabaseClient` was tested by performing a basic read query (`supabaseClient.from('events').select('*').limit(1)`), which successfully connected and returned data without errors. It has been confirmed that the application builds and runs correctly with the new client. The backward-compatibility shim in `src/utils/supabase/info.tsx` ensures that older parts of the application continue to function without requiring immediate refactoring.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install @jsr/supabase__supabase-js Dependency",
            "description": "The official Supabase JavaScript client library from the JSR registry has been added to the project's dependencies, enabling interaction with the Supabase backend.",
            "dependencies": [],
            "details": "The command `npx jsr add @supabase/supabase-js` was run, successfully adding the JSR package to the project's `package.json`.",
            "status": "done",
            "testStrategy": "Verification confirmed that `@jsr/supabase__supabase-js` is listed in `package.json` with a `jsr:` specifier.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Set Up Environment Variables for Supabase Credentials",
            "description": "A local environment file was created to securely store the Supabase project URL and anon key, replacing the previous hardcoded values.",
            "dependencies": [],
            "details": "A `.env.local` file was created in the project root containing `VITE_SUPABASE_URL='https://qhimllczaejftnuymrsr.supabase.co'` and `VITE_SUPABASE_ANON_KEY`. This file is correctly listed in `.gitignore`.",
            "status": "done",
            "testStrategy": "The environment variables were verified as accessible within the Vite application via `import.meta.env`.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Generate TypeScript Types from Supabase Schema",
            "description": "TypeScript definitions were automatically generated from the live database schema using the Supabase CLI, establishing end-to-end type safety.",
            "dependencies": [],
            "details": "The command `supabase gen types typescript --project-id qhimllczaejftnuymrsr > src/supabase/types.ts` was executed. The generated file at `src/supabase/types.ts` now contains the `Database` interface reflecting all 10 project tables.",
            "status": "done",
            "testStrategy": "The generated `src/supabase/types.ts` file was inspected and confirmed to contain a comprehensive `Database` interface reflecting the current schema.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create and Implement the Supabase Client Singleton",
            "description": "The core Supabase client instance was implemented in a dedicated file, replacing the previous hardcoded configuration.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "The file `src/supabase/client.ts` was created, which initializes and exports the typed `supabaseClient`. The now-obsolete `src/utils/supabase/info.tsx` file was updated to re-export the new client, ensuring backward compatibility for any existing imports.",
            "status": "done",
            "testStrategy": "The `src/supabase/client.ts` module compiles without TypeScript errors. The application builds and runs successfully, and IDEs provide correct type hints for the client.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify Client Connection and Remove Old Implementation",
            "description": "The new client's connection to Supabase was confirmed as successful, and the old implementation was deprecated in favor of the new singleton.",
            "dependencies": [
              4
            ],
            "details": "A test query (`supabaseClient.from('events').select('*')`) was executed and returned data successfully. Rather than being deleted, the old file `src/utils/supabase/info.tsx` was repurposed to re-export the new client, maintaining backward compatibility.",
            "status": "done",
            "testStrategy": "The successful data fetch was observed in the browser's developer console. The project builds correctly, and the re-export strategy from `src/utils/supabase/info.tsx` was verified to work as intended.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Generate a series of shell commands and code snippets to complete the subtasks. Include commands for installing dependencies, creating and populating the `.env.local` file, running the Supabase CLI for type generation, and the full code for the `src/supabase/client.ts` file."
      },
      {
        "id": 3,
        "title": "UI Layer: Implement Core Reusable Component Library",
        "description": "Build the set of reusable, accessible UI components as specified in the `add-ui-component-library` OpenSpec proposal. This component library will be based on shadcn/ui patterns, using Radix UI primitives and Tailwind CSS, and will include core elements like Button, Input, Dialog, Card, and Form controls.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "## OpenSpec Proposal\n- **Proposal ID**: `add-ui-component-library`\n- **Status**: draft\n- **Location**: `openspec/changes/add-ui-component-library/`\n\nThis task is to implement the UI component library as defined in the associated OpenSpec proposal. The proposal contains a detailed implementation checklist and technical requirements. **The first step is to review and approve this proposal.**\n\n### Implementation Guidance\nPopulate the `src/components/ui/` directory with components as defined in the OpenSpec. Use the `shadcn/ui` CLI to bootstrap components where possible, or build them manually following the same pattern. Ensure all components are styled with Tailwind CSS, support dark mode via `next-themes`, and forward refs correctly. \n\nExample for a button:\n```tsx\n// src/components/ui/button.tsx\nimport { Slot } from '@radix-ui/react-slot';\nimport { cva, type VariantProps } from 'class-variance-authority';\nimport * as React from 'react';\n// ... implementation following shadcn/ui pattern\n```",
        "testStrategy": "Manually test each component in a Storybook environment or a dedicated test page, following the test criteria outlined in the OpenSpec proposal. Verify responsiveness, accessibility (keyboard navigation, ARIA attributes), and visual consistency in both light and dark modes. Ensure components accept and render props correctly.",
        "subtasks": [
          {
            "id": 1,
            "title": "Review and Approve OpenSpec Proposal",
            "description": "Review the draft OpenSpec proposal for the UI component library to ensure it aligns with project goals and technical requirements. This must be completed before implementation begins.",
            "dependencies": [],
            "details": "Locate the proposal at `openspec/changes/add-ui-component-library/`. Review the `spec.md` and `checklist.md` files. Provide feedback, suggest changes, and formally approve the proposal to unblock the implementation subtasks. Key areas for review include the component list, accessibility standards, and React Hook Form integration strategy.",
            "status": "done",
            "testStrategy": "N/A - This is a review task. Approval is the measure of completion.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Reusable Input Component",
            "description": "Create the `Input` component for text-based user input, following the shadcn/ui pattern. This component is a fundamental building block for all forms in the application.",
            "dependencies": [
              1
            ],
            "details": "Use the `shadcn/ui` CLI command `npx shadcn-ui@latest add input` to bootstrap the component file in `src/components/ui/input.tsx`. Verify that the component correctly forwards refs and accepts all standard input props. Ensure its styling is consistent with the project's Tailwind CSS theme and supports dark mode.",
            "status": "done",
            "testStrategy": "Manually test the component in a Storybook or a dedicated test page. Verify it renders correctly in both light and dark modes. Test its behavior with different props (e.g., `type`, `placeholder`, `disabled`).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Reusable Card Component Suite",
            "description": "Create a set of `Card` components for displaying content in a structured container. This includes the main `Card` wrapper and sub-components like `CardHeader`, `CardTitle`, `CardDescription`, `CardContent`, and `CardFooter`.",
            "dependencies": [
              1
            ],
            "details": "Use the `shadcn/ui` CLI command `npx shadcn-ui@latest add card` to bootstrap the component files in `src/components/ui/card.tsx`. These components will be used extensively for displaying events, team members, and other content blocks on the public site and dashboard.",
            "status": "done",
            "testStrategy": "Manually test the `Card` by composing it with its sub-components on a test page. Verify padding, borders, and background colors are correct in light and dark modes. Ensure content passed to each section renders correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Form Components for React Hook Form Integration",
            "description": "Implement the `Form` components which act as a wrapper around `react-hook-form` to simplify form creation and state management. This includes `Form`, `FormField`, `FormItem`, `FormLabel`, `FormControl`, `FormDescription`, and `FormMessage`.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use the `shadcn/ui` CLI command `npx shadcn-ui@latest add form` to add the necessary components. These provide the structure for building accessible forms with built-in validation messages, required for the dashboard features (Tasks 7, 8). This requires `react-hook-form` to be installed as a dependency.",
            "status": "done",
            "testStrategy": "Create a sample form on a test page using `react-hook-form` and the new `Form` components with an `Input`. Test that form state is managed correctly, validation errors are displayed by `FormMessage`, and labels are correctly associated with controls.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Reusable Dialog (Modal) Component",
            "description": "Create the `Dialog` component for displaying modal windows. This is essential for confirmation prompts (e.g., delete actions in the dashboard) and for showing detailed information without navigating away from the page.",
            "dependencies": [
              1
            ],
            "details": "Use the `shadcn/ui` CLI command `npx shadcn-ui@latest add dialog` to bootstrap the component files. This will create `Dialog`, `DialogTrigger`, `DialogContent`, and other related parts. Ensure it's accessible, can be closed with the Escape key, and the overlay works correctly.",
            "status": "done",
            "testStrategy": "Test the `Dialog` by creating a trigger button that opens it. Verify that the overlay covers the page, the content renders correctly, and it can be closed via a close button, the Escape key, or by clicking the overlay. Test in both light and dark modes.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement Select and Checkbox Form Control Components",
            "description": "Add the `Select` (dropdown) and `Checkbox` components to the UI library. These are critical for building advanced forms and filtering controls, such as in the events page (Task 10) and dashboard (Tasks 7, 8).",
            "dependencies": [
              1,
              4
            ],
            "details": "Use the `shadcn/ui` CLI to add both components: `npx shadcn-ui@latest add select` and `npx shadcn-ui@latest add checkbox`. These components are based on Radix UI primitives for accessibility. They must be integrated within the `Form` component structure.",
            "status": "done",
            "testStrategy": "Add `Select` and `Checkbox` controls to the test form created in subtask 4. Verify that selecting an option or checking the box correctly updates the form state via `react-hook-form`. Test keyboard navigation for both components to ensure accessibility.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 5,
        "expansionPrompt": "For each subtask (Input, Card, Form, Dialog, etc.), generate the `shadcn/ui` CLI command to add the component. Then, provide a basic usage example for each component within a React functional component to demonstrate its props and structure."
      },
      {
        "id": 4,
        "title": "State Management: Implement Global ContentContext",
        "description": "Create the `ContentContext` to manage the global state for all content entities: events, team, partners, gallery, hero, about, and settings. This context will handle fetching data from Supabase and providing it to the application.",
        "details": "Create `src/contexts/ContentContext.tsx`. The provider component, `ContentProvider`, will fetch all initial data from Supabase in a `useEffect` hook. The context will expose the data, loading states, and error states. It will also provide functions to mutate the data (e.g., `addEvent`, `updateTeamMember`), which will call the Supabase client and then update the local state.\n\n```tsx\n// src/contexts/ContentContext.tsx\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { supabaseClient } from '@/supabase/client';\n// ...\n\nconst ContentContext = createContext<any>(null);\n\nexport const ContentProvider = ({ children }) => {\n  const [events, setEvents] = useState([]);\n  // ... other states\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const { data: eventsData } = await supabaseClient.from('events').select('*');\n      setEvents(eventsData || []);\n      // ... fetch other data\n    };\n    fetchData();\n  }, []);\n\n  return <ContentContext.Provider value={{ events, ... }}>{children}</ContentContext.Provider>;\n};\n\nexport const useContent = () => useContext(ContentContext);\n```\n<info added on 2025-11-07T00:45:32.526Z>\n\"\\n\\n## OpenSpec Proposal\\n- **Proposal ID**: implement-content-context-supabase\\n- **Status**: draft (pending review)\\n- **Location**: `openspec/changes/implement-content-context-supabase/`\\n\\nThe proposal, located at `proposal.md` in the directory above, covers the implementation of Supabase data fetching, loading/error states, and mutation functions for the ContentContext.\"\n</info added on 2025-11-07T00:45:32.526Z>",
        "testStrategy": "Write integration tests for the `ContentProvider`. Mock the `supabaseClient` to return predefined data. Wrap a test component with the provider and use the `useContent` hook to assert that the correct data is available, loading states are handled, and mutation functions are called as expected.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define ContentContext Shape and Provider Boilerplate",
            "description": "Create the file at `src/contexts/ContentContext.tsx` and define the basic structure. This includes defining the `ContentContextType` interface, creating the context with `createContext`, setting up the `ContentProvider` component, and exporting the `useContent` custom hook.",
            "dependencies": [],
            "details": "In `src/contexts/ContentContext.tsx`, import React and necessary types from `src/types/`. Define an interface `ContentContextType` that outlines all the data arrays (events, team, etc.), loading and error states, and the signatures for future mutation functions. Create the initial context and the `ContentProvider` that returns the `ContentContext.Provider`.",
            "status": "done",
            "testStrategy": "Ensure the file compiles without type errors. Create a simple test page that consumes the context with `useContent` and verifies that the initial (empty) values are provided without crashing the application.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Initial Data Fetching from Supabase",
            "description": "In the `ContentProvider`, implement a `useEffect` hook to fetch all initial data for events, team, partners, gallery, hero, about, and settings from the Supabase database upon component mount.",
            "dependencies": [
              1
            ],
            "details": "Import the `supabaseClient` from `src/supabase/client.ts`. Inside the `useEffect` hook, create an async function `fetchData`. Use `Promise.all` to concurrently fetch data from all required Supabase tables (e.g., `supabaseClient.from('events').select('*')`). Use `useState` hooks to store the data for each entity.",
            "status": "done",
            "testStrategy": "Wrap a test component with the provider. Use `useEffect` in the test component to check if the state variables (e.g., `events`, `team`) are populated with data after the initial render. Mock the `supabaseClient` to return predictable data for testing.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Loading and Error State Management",
            "description": "Enhance the `ContentProvider` to manage and expose global loading and error states related to the initial data fetch.",
            "dependencies": [
              2
            ],
            "details": "Introduce two new states: `loading` (boolean) and `error` (string | null). Set `loading` to `true` before the `Promise.all` call begins. In a `try...catch` block, set `loading` to `false` in the `finally` block. If an error occurs during the fetch, catch it, set the `error` state with an appropriate message, and log the full error.",
            "status": "done",
            "testStrategy": "Test three scenarios by mocking `supabaseClient`: 1) Successful fetch: assert `loading` goes from true to false and `error` is null. 2) Failed fetch: assert `loading` goes from true to false and `error` is populated. 3) Slow fetch: verify the `loading` state is true while the promise is unresolved.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Mutation Functions for Events Entity",
            "description": "Add functions to the context for creating, updating, and deleting events. These functions will handle the Supabase API calls and update the local state to reflect the changes.",
            "dependencies": [
              1
            ],
            "details": "Define `addEvent`, `updateEvent`, and `deleteEvent` functions within the `ContentProvider`. Each function will take the necessary data as arguments, call the corresponding Supabase method (`.insert()`, `.update()`, `.delete()`), and handle any errors. After a successful mutation, either refetch the events list or apply an optimistic update to the `events` state using the `setEvents` setter.",
            "status": "done",
            "testStrategy": "In an integration test, call a mutation function like `addEvent`. Mock the `supabaseClient` to simulate a successful API call. Assert that the Supabase client method was called with the correct arguments and that the local `events` state in the context is updated accordingly.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate ContentProvider into the Application Root",
            "description": "Wrap the root component of the application with the `ContentProvider` to make the global state available to all child components.",
            "dependencies": [
              3,
              4
            ],
            "details": "Locate the application's root entry point, which is likely `src/pages/_app.tsx` in a Next.js project. Import the `ContentProvider` and wrap the main `<Component {...pageProps} />` with it. This ensures that any page or component in the application can use the `useContent` hook to access global data, loading/error states, and mutation functions.",
            "status": "done",
            "testStrategy": "Manually navigate to several different pages of the application. On each page, use browser developer tools to inspect a component that calls `useContent`. Verify that the context provides the expected data without causing any application-wide errors. Confirm that data persists across navigation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Break down the implementation of mutation functions for each major data entity. Create separate subtasks for implementing CRUD functions (create, update, delete) for Team, Partners, and Gallery within the ContentContext, following the pattern established for Events.",
        "updatedAt": "2025-11-07T00:53:19.749Z"
      },
      {
        "id": 5,
        "title": "Navigation: Implement Custom Client-Side Router",
        "description": "Successfully implemented a custom, lightweight client-side router, completing the work specified in the `refactor-router-system` OpenSpec proposal. The new system uses the React Context API and the browser's History API for navigation and is built around a flexible path-based routes object pattern.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "## OpenSpec Proposal\n- **Proposal ID**: `refactor-router-system`\n- **Status**: approved\n- **Location**: `openspec/changes/refactor-router-system/`\n\n### Implementation Summary\nThe implementation followed the specifications in this proposal, and the checklist in `tasks.md` is now complete. The legacy page-based router was successfully replaced by the new path-based system located in `src/components/router/`.\n\nThe final implementation in `src/components/router/index.tsx` includes a `RouterProvider` that manages the application's navigation state and a `Router` component that dynamically renders page components. The system has been fully integrated into `src/App.tsx`.",
        "testStrategy": "Manual and integration testing was completed successfully. Navigation was verified by clicking `Link` components and using browser back/forward buttons, confirming that the correct page component renders and the URL updates as expected. All criteria in the implementation checklist from `openspec/changes/refactor-router-system/tasks.md` have been met.",
        "subtasks": [
          {
            "id": 1,
            "title": "Created RouterContext and Initial RouterProvider Structure",
            "description": "The file `src/components/router/index.tsx` was created, defining the `RouterContext` and the basic `RouterProvider` component, which formed the foundation of the routing system.",
            "dependencies": [],
            "details": "As specified in `openspec/changes/refactor-router-system/`, the file `src/components/router/index.tsx` was created. The context type was defined as `{ path: string; navigate: (to: string) => void; } | null`. The `RouterProvider` component was implemented to accept `children` and wrap them with the `RouterContext.Provider`, passing the current path state (initialized from `window.location.pathname`) and the `navigate` function.",
            "status": "done",
            "testStrategy": "The `RouterProvider` was confirmed to render its children without issues. React DevTools was used to inspect the context provider and verify it held the initial path value correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrated Browser History API into RouterProvider",
            "description": "The `RouterProvider` was enhanced to handle browser navigation by implementing the `navigate` function with `pushState` and adding a `popstate` event listener.",
            "dependencies": [
              1
            ],
            "details": "In `RouterProvider`, the `navigate` function was implemented to call `window.history.pushState({}, '', to)` and update the component's `path` state. A `useEffect` hook was added to register a `popstate` event listener on mount, which updates the path state, with a cleanup function to remove the listener on unmount.",
            "status": "done",
            "testStrategy": "The `navigate` function was tested and verified to update the URL and re-render the component. The browser's back and forward buttons were tested to ensure the `popstate` listener correctly updated the path state.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Built `useRouter` Hook and Page-Rendering `Router` Component",
            "description": "A `useRouter` hook was created for context access, and a `Router` component was built that uses a routes object to render the correct page based on the current path.",
            "dependencies": [
              1,
              2
            ],
            "details": "The `useRouter` hook was implemented to call `useContext(RouterContext)` and throw an error if used outside the provider. The `Router` component was built to implement the 'routes object pattern', accepting a `routes` prop and rendering the component for the current path or a `404` fallback.",
            "status": "done",
            "testStrategy": "A test page with `RouterProvider` and `Router` confirmed that changing the path rendered the correct component from a mock `routes` object.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Developed a Reusable `Link` Component for Navigation",
            "description": "A reusable `Link` component was created for declarative, internal navigation that uses the router's `navigate` function to prevent full page reloads.",
            "dependencies": [
              3
            ],
            "details": "A `Link.tsx` component was created in `src/components/router/`. Its `onClick` handler was implemented to call `event.preventDefault()` and then the `navigate(to)` function obtained from the `useRouter` hook. The underlying `<a>` tag's `href` is set to the `to` prop.",
            "status": "done",
            "testStrategy": "Rendered `Link` components were clicked, and it was asserted that the URL changed without a page refresh and the correct component was displayed by the `Router`.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrated RouterProvider and Router into the Main App",
            "description": "The new router system was wired up in `src/App.tsx`. The application was wrapped with `RouterProvider`, and `Router` and `Link` components were used to define routes and navigation.",
            "dependencies": [
              3,
              4
            ],
            "details": "In `src/App.tsx`, the router system was fully integrated. The main app structure is now wrapped with `<RouterProvider>`, and a `routes` object is defined and passed to `<Router routes={...} />`. The main navigation menu was updated to use the new `Link` component.",
            "status": "done",
            "testStrategy": "The application was run and all defined routes were manually navigated. The URL updated correctly, the proper pages rendered, and browser back/forward buttons worked as expected.",
            "parentId": "undefined"
          }
        ],
        "complexity": 10,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Given the extreme complexity and architectural conflict, provide two expansion paths. Path A: Detail the steps to implement the custom router as described, including code for the `RouterProvider`, `useRouter` hook, and `Link` component. Path B: Propose an alternative, framework-aligned implementation using the Next.js App Router, detailing how to create layouts and pages and use `next/link` for navigation."
      },
      {
        "id": "6",
        "title": "Admin UI: Build Dashboard Layout and Navigation",
        "description": "Refactor the admin dashboard layout to integrate with the new client-side router. This involves migrating from a state-based navigation model to a URL-based system, as outlined in the `integrate-dashboard-router` OpenSpec proposal. The goal is to make the dashboard sections (Events, Team, etc.) addressable via unique URLs like `/admin/events`.",
        "status": "pending",
        "dependencies": [
          "3",
          "5"
        ],
        "priority": "medium",
        "details": "This task focuses on updating the existing dashboard components (`DashboardLayout.tsx`, `SideNav.tsx`, `Header.tsx`) to align with the URL-based routing system implemented in Task 5. The `currentPage` prop and other state-based navigation logic will be removed.\n\n## OpenSpec Proposal\n- **Proposal ID**: `integrate-dashboard-router`\n- **Status**: `draft`\n- **Location**: `openspec/changes/integrate-dashboard-router/`\n\nThe `DashboardLayout.tsx` will be refactored to use the application's router context to render the appropriate child page based on the current URL, likely using a nested route outlet pattern. The `SideNav` component will be updated to use the `Link` component from `src/components/router/index.tsx` for navigation.\n\n```tsx\n// src/components/dashboard/DashboardLayout.tsx (Refactored)\nimport { SideNav } from './SideNav';\nimport { Header } from './Header';\nimport { Outlet } from '@/components/router'; // Assuming an Outlet component for nested routes\n\nexport const DashboardLayout = () => {\n  return (\n    <div className='flex h-screen bg-gray-100'>\n      <SideNav />\n      <div className='flex-1 flex flex-col'>\n        <Header />\n        <main className='p-8 flex-1 overflow-y-auto'>\n          <Outlet /> {/* Renders the matched nested route component */}\n        </main>\n      </div>\n    </div>\n  );\n};\n```",
        "testStrategy": "Manually test the layout on various screen sizes to ensure responsiveness is maintained. Verify that all navigation links in the sidebar update the browser's URL and render the correct page component without a full-page refresh. Test direct navigation by manually entering URLs (e.g., `/admin/team`) into the address bar. Confirm that the previously state-based navigation has been fully removed.",
        "subtasks": [
          {
            "id": 1,
            "title": "Review `integrate-dashboard-router` Proposal and Existing Code",
            "description": "Analyze the `integrate-dashboard-router` OpenSpec proposal and review the current implementation of `DashboardLayout.tsx`, `SideNav.tsx`, and the custom router from Task 5.",
            "dependencies": [],
            "details": "Familiarize yourself with the proposal located at `openspec/changes/integrate-dashboard-router/`. Examine `src/components/dashboard/DashboardLayout.tsx` and `SideNav.tsx` to understand the current state-based navigation logic (e.g., `currentPage` props, `onNavigate` callbacks). Also, review `src/components/router/index.tsx` to understand the `useRouter` hook and `Link` component APIs.",
            "status": "pending",
            "testStrategy": "Confirm that the analysis identifies all files and code sections that need to be refactored to switch from state-based to URL-based routing. Create a checklist of components and props to be removed or modified."
          },
          {
            "id": 2,
            "title": "Refactor `SideNav.tsx` to Use Router Link Component",
            "description": "Update the sidebar navigation to use URL-based links instead of state-based callbacks. The active link should be determined by the current URL path.",
            "dependencies": [
              1
            ],
            "details": "In `src/components/dashboard/SideNav.tsx`, replace the existing `<a>` or `<div>` elements and their `onClick` handlers with the `Link` component from the custom router (`src/components/router/index.tsx`). Set the `to` prop of each `Link` to the correct admin path (e.g., `to='/admin/events'`). Implement logic to determine the active link by comparing the link's path with the current `location.pathname` from the `useRouter` hook.",
            "status": "pending",
            "testStrategy": "Verify that clicking links in the `SideNav` component updates the browser's URL correctly. Check that the styling for the 'active' link is applied correctly based on the current URL path."
          },
          {
            "id": 3,
            "title": "Update Router Configuration for Nested Admin Routes",
            "description": "Modify the application's main router configuration to handle nested routes under the `/admin` path, rendering the `DashboardLayout` as the parent layout.",
            "dependencies": [
              2
            ],
            "details": "In the main application router setup (likely in `App.tsx` or a dedicated routes file), define a parent route for `/admin` that renders the `DashboardLayout.tsx` component. Configure nested routes for each admin section (e.g., `events`, `team`) that render their respective page components inside the `DashboardLayout`'s outlet.",
            "status": "pending",
            "testStrategy": "Navigate to `/admin/events` and verify that the `DashboardLayout` is rendered with the `EventsPage` component inside its main content area. Repeat for other admin sections to ensure the nested routing is working correctly."
          },
          {
            "id": 4,
            "title": "Refactor `DashboardLayout.tsx` and Remove State Logic",
            "description": "Update the main layout component to render nested routes and remove all obsolete state-based navigation props and logic.",
            "dependencies": [
              3
            ],
            "details": "Modify `src/components/dashboard/DashboardLayout.tsx` to remove any props like `currentPage` or `onNavigate`. If the router implementation requires it, add an `<Outlet />` component (or equivalent) in the `main` content area to serve as the rendering target for the nested child routes defined in the previous subtask.",
            "status": "pending",
            "testStrategy": "Confirm that the `DashboardLayout` component no longer accepts or uses any state-based navigation props. Check the browser console for any warnings or errors related to removed props. Verify that the layout renders correctly with the child route component."
          },
          {
            "id": 5,
            "title": "Verify Responsiveness and Finalize Integration",
            "description": "Ensure the existing responsive behavior of the dashboard layout is preserved after the refactoring and clean up any remaining dead code.",
            "dependencies": [
              2,
              4
            ],
            "details": "Thoroughly test the dashboard layout across different screen sizes (desktop, tablet, mobile). Verify that the `SideNav` collapses and the hamburger menu in the `Header` toggles its visibility correctly on smaller screens. Remove any unused variables, imports, or functions related to the old navigation system from all modified dashboard components.",
            "status": "pending",
            "testStrategy": "Using browser dev tools, confirm the layout adapts correctly to different viewports. Check that the mobile menu toggle functionality is intact. Perform a final code review to ensure no legacy navigation code remains."
          }
        ]
      },
      {
        "id": 7,
        "title": "Feature: Implement Event Management CRUD in Dashboard",
        "description": "Develop the complete CRUD (Create, Read, Update, Delete) functionality for events within the admin dashboard. This includes a page to list all events and a form to create/edit event details.",
        "details": "Create `DashboardEvents.tsx` to display a table or grid of events fetched from `ContentContext`. Add buttons for 'Edit' and 'Delete'. Create `DashboardEventsNew.tsx` with a form managed by `React Hook Form`. The form should include all fields from the `Event` type. On submit, call a function from `ContentContext` to persist the data to Supabase. Also, implement media uploads for `featured_image` and `gallery_images` using Supabase Storage.\n\n```tsx\n// In DashboardEventsNew.tsx\nconst { register, handleSubmit, formState: { errors } } = useForm<Event>();\nconst { createEvent } = useContent(); // from ContentContext\n\nconst onSubmit = (data) => {\n  createEvent(data);\n};\n\nreturn <form onSubmit={handleSubmit(onSubmit)}>...</form>;\n```",
        "testStrategy": "Perform end-to-end testing: 1. Create a new event and verify it appears in the event list and the Supabase database. 2. Edit the event and confirm the changes are saved. 3. Delete the event and ensure it's removed from the UI and database. Test form validation for all required fields.",
        "priority": "medium",
        "dependencies": [
          "4",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Event List View in Dashboard",
            "description": "Create the `DashboardEvents.tsx` component to display a list of all events. This component will fetch event data from `ContentContext` and render it in a table, including 'Edit' and 'Delete' buttons for each event.",
            "dependencies": [],
            "details": "Create a new file `src/app/dashboard/events/page.tsx` (or equivalent route). This component will consume the `events` array from `ContentContext`. Use the `Table` component from `src/components/ui` to structure the data. For each event, display key fields like title, date, and status. Add placeholder `Button` components for 'Edit' and 'Delete' that will be wired up in later tasks. Include a 'Create New Event' button that will navigate to the creation page.",
            "status": "pending",
            "testStrategy": "Verify the component renders a table of events correctly. Confirm that the 'Create New Event', 'Edit', and 'Delete' buttons are visible for each event row. Test that the page handles an empty list of events gracefully.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build Event Creation/Edit Form Component",
            "description": "Develop the `DashboardEventsForm.tsx` component using `React Hook Form` to handle event data entry. The form should include all fields specified in the `Event` type, such as title, description, date, and location.",
            "dependencies": [
              1
            ],
            "details": "Create a reusable form component `src/components/dashboard/DashboardEventsForm.tsx`. Use `React Hook Form` and integrate with `shadcn/ui` components (`Input`, `Textarea`, `DatePicker`, etc.). The form should accept an optional `defaultValues` prop for editing existing events. For now, the submit handler can log the form data to the console. Do not implement file uploads in this step.",
            "status": "pending",
            "testStrategy": "Manually test the form by filling out all fields. Verify that `React Hook Form` validation works as expected for required fields. Check that the form state is managed correctly. If passing `defaultValues`, confirm the form fields are pre-populated.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Event Creation and File Upload Logic",
            "description": "Integrate the event form with `ContentContext` to create new events in Supabase. This includes implementing the `createEvent` function and handling file uploads for `featured_image` and `gallery_images` to Supabase Storage.",
            "dependencies": [
              2
            ],
            "details": "Create a new page `src/app/dashboard/events/new/page.tsx` that uses the `DashboardEventsForm`. In `ContentContext`, implement `createEvent(eventData)`. This function will first upload any media files to a designated Supabase Storage bucket (e.g., 'event-media') and get their public URLs. Then, it will insert the event data, including the media URLs, into the 'events' table. The form's `onSubmit` handler should call this context function and redirect to the events list on success.",
            "status": "pending",
            "testStrategy": "Perform an end-to-end test: Fill out and submit the 'New Event' form. Verify the new event appears in the Supabase 'events' table with correct data. Check Supabase Storage to confirm that the featured image and gallery images have been uploaded successfully. Ensure the user is redirected back to the event list.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Event Update Functionality",
            "description": "Enable editing of existing events. This involves creating a dynamic route for editing, fetching the specific event's data, populating the form, and handling the update logic via `ContentContext`.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create a dynamic route `src/app/dashboard/events/edit/[id]/page.tsx`. This page will fetch the event ID from the URL params. In `ContentContext`, create a `getEventById(id)` function to retrieve a single event from Supabase. Use this data to populate the `DashboardEventsForm` via its `defaultValues` prop. Implement an `updateEvent(id, eventData)` function in the context to update the record in Supabase. The form's `onSubmit` will call this update function.",
            "status": "pending",
            "testStrategy": "Navigate to an event's edit page from the list view. Confirm the form is pre-populated with the correct data. Modify several fields and submit the form. Verify the changes are reflected in both the UI list and the Supabase database. Test that image uploads also work during an update.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Event Deletion with Confirmation",
            "description": "Wire up the 'Delete' button in the event list. Implement the `deleteEvent` function in `ContentContext`, which should remove the event from the database and its associated images from Supabase Storage. Add a confirmation dialog to prevent accidental deletion.",
            "dependencies": [
              1
            ],
            "details": "In `ContentContext`, create a `deleteEvent(id)` function. This function must first delete any associated files from Supabase Storage before deleting the event record from the table. In `DashboardEvents.tsx`, wire the 'Delete' button to trigger an `AlertDialog` component from `shadcn/ui`. On confirmation within the dialog, call the `deleteEvent` function from the context with the event's ID.",
            "status": "pending",
            "testStrategy": "Click the 'Delete' button for an event. Verify a confirmation dialog appears. Click 'Cancel' and confirm nothing happens. Click 'Delete' again, then 'Confirm'. Verify the event is removed from the UI list and the Supabase database. Check Supabase Storage to ensure the associated files have also been deleted.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break this feature down into a full implementation plan. For the list view, show how to use a `shadcn/ui` Table. For the form, provide a `react-hook-form` setup integrated with `zod` for validation. For the create/update logic, detail the Supabase Storage upload process followed by the database insert/update, encapsulated within a `ContentContext` function."
      },
      {
        "id": 8,
        "title": "Feature: Implement CMS for Team, Partners, and Gallery",
        "description": "Create the dashboard management interfaces for Team Members, Partners/Sponsors, and the site-wide Gallery. Follow the same CRUD pattern established in the Event Management module.",
        "details": "Create three new dashboard pages: `DashboardTeam.tsx`, `DashboardPartners.tsx`, and `DashboardGallery.tsx`. Each page will have a list view and a form for creating/editing items, similar to the event management implementation. Use the corresponding types and context functions (`createTeamMember`, `updatePartner`, etc.) for data operations. Reuse form components and layout patterns to ensure consistency across the dashboard.",
        "testStrategy": "For each module (Team, Partners, Gallery), perform full E2E CRUD tests. Verify that creating, updating, and deleting items works correctly and the data is persisted in Supabase. Check that image uploads for team member photos and partner logos are functional.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Data Layer for Team, Partners, and Gallery in ContentContext",
            "description": "Extend the existing `ContentContext.tsx` to manage state and CRUD operations for Team Members, Partners, and Gallery Items. This involves adding new state arrays and creating async functions for create, read, update, and delete operations that interact with the Supabase client.",
            "dependencies": [],
            "details": "In `src/context/ContentContext.tsx`, add state variables for `teamMembers`, `partners`, and `galleryItems`. Implement and export functions like `fetchTeamMembers`, `createTeamMember`, `updateTeamMember`, `deleteTeamMember`, and repeat this pattern for `Partner` and `GalleryItem`. These functions will encapsulate the Supabase API calls, including storage calls for image uploads (team member photos, partner logos, gallery images).",
            "status": "pending",
            "testStrategy": "Write unit tests for the new context functions to ensure they correctly call the Supabase client. Mock the Supabase client to verify parameters and return values. Check that state updates correctly upon successful operations.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build Team Management CRUD Interface",
            "description": "Create the dashboard page for managing team members. This includes a list view to display all members and a form for adding or editing a team member, including their photo.",
            "dependencies": [
              1
            ],
            "details": "Create files under `src/app/dashboard/team/`. The main page (`page.tsx`) will fetch and display team members from `ContentContext` in a data table, similar to `DashboardEvents`. Implement `new/page.tsx` and `[id]/edit/page.tsx` with a `react-hook-form` instance that uses the `TeamMember` type. Reuse existing `Input`, `Textarea`, and a file upload component for the form fields.",
            "status": "pending",
            "testStrategy": "Manually test the full CRUD flow. Create a new team member, verify they appear in the list. Edit their details and photo, and confirm the changes are saved. Delete the member and ensure they are removed from the UI and the database.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build Partner Management CRUD Interface",
            "description": "Create the dashboard page for managing partners and sponsors. This includes a list view to display all partners and a form for adding or editing partner details, including their logo.",
            "dependencies": [
              1
            ],
            "details": "Create files under `src/app/dashboard/partners/`. The main page (`page.tsx`) will display partners from `ContentContext` in a data table. Implement `new/page.tsx` and `[id]/edit/page.tsx` with a form based on the `Partner` type. Follow the same component and form management patterns established in the Team and Event modules.",
            "status": "pending",
            "testStrategy": "Perform end-to-end testing. Add a new partner with a logo, check if it's displayed correctly. Update the partner's information and verify the changes persist. Delete the partner and confirm its removal.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build Gallery Management CRUD Interface",
            "description": "Create the dashboard page for managing site-wide gallery images. This will primarily feature a grid view of images and a form for uploading new images and editing their associated metadata (e.g., title, description).",
            "dependencies": [
              1
            ],
            "details": "Create files under `src/app/dashboard/gallery/`. The main `page.tsx` will fetch and display images from `ContentContext`, likely in a `Card`-based grid. Implement `new/page.tsx` and `[id]/edit/page.tsx` with a form focused on image uploads and text inputs for metadata, based on the `GalleryItem` type. This may require a more visual layout than the other data tables.",
            "status": "pending",
            "testStrategy": "Test the full CRUD lifecycle for gallery items. Upload a new image and verify it appears in the gallery grid. Edit its title/description and confirm the update. Delete the image and ensure it's removed from storage and the database.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update Dashboard Navigation to Include New Pages",
            "description": "Integrate the new Team, Partner, and Gallery management pages into the main dashboard navigation sidebar to make them accessible to administrators.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Locate the dashboard sidebar or layout component (e.g., `src/app/dashboard/layout.tsx` or a dedicated `Sidebar.tsx` component). Add new navigation links for 'Team', 'Partners', and 'Gallery'. Point these links to `/dashboard/team`, `/dashboard/partners`, and `/dashboard/gallery` respectively. Ensure the active link styling works correctly.",
            "status": "pending",
            "testStrategy": "Manually verify the dashboard sidebar. Click on each new link (Team, Partners, Gallery) and confirm it navigates to the correct page. Check that the active state of the navigation item is highlighted correctly when on the corresponding page.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Generate a plan that reuses patterns from Task 7. For subtask 1, define the new functions to be added to `ContentContext`. For subtasks 2, 3, and 4, outline the component structure and specify which components (Table, Card, Form) can be reused or adapted for each CMS section."
      },
      {
        "id": 9,
        "title": "Public UI: Implement Public-Facing Landing Page",
        "description": "Build the main public `LandingPage.tsx` component, which assembles various sections like Hero, Featured Events, Partners, Team, and About. All content should be dynamically fetched from the `ContentContext`.",
        "details": "Create `src/components/LandingPage.tsx`. This component will use the `useContent` hook to get all necessary data (hero content, events, partners, team members). It will then pass this data as props to smaller, dedicated section components (e.g., `HeroSection`, `FeaturedEventsSection`). Ensure the page is fully responsive and visually matches the Figma design.\n\n```tsx\n// src/components/LandingPage.tsx\nimport { useContent } from '@/contexts/ContentContext';\n// Import section components\n\nexport const LandingPage = () => {\n  const { heroContent, events, partners, team } = useContent();\n\n  return (\n    <div>\n      <HeroSection content={heroContent} />\n      <FeaturedEventsSection events={events} />\n      <PartnersSection partners={partners} />\n      {/* ...other sections */}\n    </div>\n  );\n};\n```",
        "testStrategy": "Verify that the landing page renders correctly with data fetched from the `ContentContext`. Manually test by updating content in the admin dashboard (e.g., change the Hero title) and confirming the landing page updates automatically (after a refresh, or in real-time if implemented).",
        "priority": "medium",
        "dependencies": [
          "4",
          "5",
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create LandingPage Component Shell and Integrate into App Router",
            "description": "Create the initial file `src/components/LandingPage.tsx` with a basic functional component structure. This component will serve as the main assembler for all landing page sections. Then, integrate it into the root page of the application.",
            "dependencies": [],
            "details": "Create the file at `src/components/LandingPage.tsx`. Define and export a React component named `LandingPage`. Update the root page file, likely `src/app/page.tsx`, to import and render the `<LandingPage />` component as its primary content.",
            "status": "pending",
            "testStrategy": "Run the development server and navigate to the application's root URL. Verify that any placeholder content from the newly created `LandingPage` component is successfully rendered in the browser.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate ContentContext and Fetch Dynamic Data",
            "description": "In the `LandingPage.tsx` component, import and utilize the `useContent` hook from `ContentContext` to fetch all necessary data for the page sections. Destructure the data and implement basic loading/error states.",
            "dependencies": [
              1
            ],
            "details": "Import `useContent` from `src/contexts/ContentContext.tsx`. Call the hook within the `LandingPage` component to retrieve `heroContent`, `events`, `partners`, and `team`. Add logic to display a loading indicator while data is being fetched and an error message if the fetch fails.",
            "status": "pending",
            "testStrategy": "Use React DevTools or `console.log` to inspect the values returned by the `useContent` hook. Confirm that the data structures for `heroContent`, `events`, etc., are populated correctly. Test the loading state by simulating a slow network connection.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Import and Render the Hero Section with Dynamic Data",
            "description": "Import the `HeroSection` component (from Task 8) into `LandingPage.tsx`. Pass the `heroContent` object, fetched from the context in the previous step, to the `HeroSection` as a prop.",
            "dependencies": [
              2
            ],
            "details": "Add an import statement for `HeroSection` from its file path (e.g., `src/components/sections/HeroSection.tsx`). Inside the `LandingPage` return statement, render the component like `<HeroSection content={heroContent} />`. This wires up the first major visual block of the page.",
            "status": "pending",
            "testStrategy": "Visually verify on the home page that the Hero section appears correctly with the title, description, and call-to-action button text populated from the `heroContent` data object provided by the context.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Assemble and Render Remaining Content Sections",
            "description": "Import the `FeaturedEventsSection`, `PartnersSection`, and `TeamSection` components. Render them within the `LandingPage` component, passing the corresponding data (`events`, `partners`, `team`) as props to each.",
            "dependencies": [
              3
            ],
            "details": "Sequentially import and render the remaining section components below the `HeroSection`. For example: `<FeaturedEventsSection events={events} />`, `<PartnersSection partners={partners} />`, and `<TeamSection team={team} />`. Ensure each component receives the correct data prop from the `useContent` hook.",
            "status": "pending",
            "testStrategy": "Scroll down the landing page and confirm that the Featured Events, Partners, and Team sections are all rendered in the correct order. Verify that each section is correctly populated with dynamic data, such as showing the correct event cards and partner logos.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Overall Page Layout, Spacing, and Responsiveness",
            "description": "Wrap all the assembled sections in a main layout container. Apply Tailwind CSS utilities to establish vertical spacing between sections and ensure the entire page layout is fully responsive, matching the Figma design across all breakpoints.",
            "dependencies": [
              4
            ],
            "details": "Use a `main` or `div` element in `LandingPage.tsx` to wrap all section components. Apply a class like `flex flex-col` to the wrapper and use `gap-y-16` or a similar utility to create consistent vertical spacing. Add responsive prefixes (e.g., `md:gap-y-24`) to adjust the layout for different screen sizes.",
            "status": "pending",
            "testStrategy": "Using browser developer tools, view the landing page at various screen widths (mobile, tablet, desktop). Confirm that all sections stack and reflow correctly without horizontal overflow or broken layouts. Check that the spacing between sections is appropriate for each viewport size.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Generate the skeleton code for `LandingPage.tsx`, showing how it uses the `useContent` hook and passes data to placeholder section components (e.g., `<HeroSection />`, `<FeaturedEventsSection />`). Also, provide an example of one of the section components, showing how it receives and renders the props."
      },
      {
        "id": 10,
        "title": "Public UI: Implement All-Events Page with Filtering and Search",
        "description": "Develop the `AllEventsPage.tsx` to display all 'upcoming' events. Implement client-side filtering (by date, category), sorting, and a search functionality.",
        "details": "Create `src/components/AllEventsPage.tsx`. Fetch the list of all events from `ContentContext`. Use local state (`useState`) to manage filter criteria (e.g., search query, selected category). Apply these filters to the event list before rendering the event cards. Implement pagination if the list is expected to be long. The search should filter events based on title, description, or artist names.\n\n```tsx\n// src/components/AllEventsPage.tsx\nconst { events } = useContent();\nconst [searchQuery, setSearchQuery] = useState('');\n\nconst filteredEvents = events.filter(event => \n  event.title.toLowerCase().includes(searchQuery.toLowerCase())\n);\n\nreturn <div>{/* Render filter controls and filteredEvents */}</div>;\n```",
        "testStrategy": "Manually test the filtering and search functionality. Enter a search query and verify that only matching events are displayed. Use the filter controls for category and date, and confirm the list updates correctly. Check that pagination works as expected if implemented.",
        "priority": "medium",
        "dependencies": [
          "4",
          "5",
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create AllEventsPage Component and Fetch Events",
            "description": "Create the basic structure for the `AllEventsPage.tsx` component. Use the `useContent` hook to fetch the list of all events and display a preliminary list of upcoming events to ensure data is being correctly retrieved.",
            "dependencies": [],
            "details": "Create the file `src/components/AllEventsPage.tsx`. Inside the component, call `useContent()` to get the `events` array. Filter this array to show only 'upcoming' events (events with a date in the future). Map over the filtered array and render a simple placeholder for each event, like a `<div>` with the event title. Add a route for '/events' in `src/components/Router.tsx` to render this new component.",
            "status": "pending",
            "testStrategy": "Verify that the page renders at the '/events' route and displays a list of titles for all upcoming events fetched from the context. Check the console for any errors related to data fetching.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Search Bar UI and Filtering Logic",
            "description": "Add a search input field to the `AllEventsPage`. Implement the client-side logic to filter the displayed events based on a search query that matches the event title, description, or artist names.",
            "dependencies": [
              1
            ],
            "details": "In `AllEventsPage.tsx`, add an `<Input />` component from `src/components/ui/input.tsx`. Create a `useState` hook for the `searchQuery`. Create a `useMemo` hook to compute the `filteredEvents` list by applying the search query to the upcoming events array. The search should be case-insensitive and check against `event.title`, `event.description`, and any associated artist fields.",
            "status": "pending",
            "testStrategy": "Type various queries into the search bar. Confirm that the list of events updates in real-time to show only events that match the query in their title, description, or artist details. Test with empty queries and queries that yield no results.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Category and Date Filter Controls",
            "description": "Add UI controls for filtering events by category and date. This will include dropdowns or button groups to allow users to narrow down the event list.",
            "dependencies": [
              2
            ],
            "details": "Add a `<Select />` component from `src/components/ui/select.tsx` for category filtering. Populate it with unique categories from the events list. Add another set of controls (e.g., `<Button />` group or a date picker component) for date filtering (e.g., 'This Week', 'This Month'). Use `useState` to manage the state for these filters. Update the filtering logic to incorporate these new criteria along with the search query.",
            "status": "pending",
            "testStrategy": "Select a category from the dropdown and verify that only events of that category are displayed. Test the date filters and confirm the list updates accordingly. Ensure that the category, date, and search filters can all be applied simultaneously and work correctly together.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Sorting Functionality",
            "description": "Add a UI control, such as a dropdown, to allow users to sort the filtered list of events. Implement sorting by date (ascending/descending) and by title (A-Z).",
            "dependencies": [
              3
            ],
            "details": "Add a `<Select />` component to control the sort order. Options should include 'Date (Newest First)', 'Date (Oldest First)', and 'Title (A-Z)'. Use a `useState` hook to manage the selected sort option. Apply the sorting logic to the filtered event list *after* all filters (search, category, date) have been applied but *before* pagination.",
            "status": "pending",
            "testStrategy": "Test each sorting option. Verify that changing the sort order correctly reorganizes the currently displayed list of events without affecting the active filters.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Refine Event Display with Card Component and Add Pagination",
            "description": "Replace the simple event list display with a more polished UI using the reusable `Card` component. Implement client-side pagination to handle large numbers of events efficiently.",
            "dependencies": [
              4
            ],
            "details": "For each event in the final sorted and filtered list, render a `<Card />` component from `src/components/ui/card.tsx` to display the event details (image, title, date, etc.) in a structured format. Implement pagination by using `useState` for `currentPage`. Calculate the total number of pages and use `.slice()` to display only the events for the current page. Add 'Previous' and 'Next' `<Button />` components to navigate between pages.",
            "status": "pending",
            "testStrategy": "Verify that events are now displayed in styled cards. If there are more events than the page limit, check that pagination controls appear. Click 'Next' and 'Previous' to ensure the correct subset of events is displayed on each page. The 'Previous' button should be disabled on page 1.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Provide a detailed implementation plan. Show the state management using `useState` for search query and filters. Write the core filtering logic using `useMemo` to create a derived list of events. Demonstrate how to implement pagination using `slice` and state for the current page."
      },
      {
        "id": 11,
        "title": "Backend Foundation: Rebuild Supabase Project from Scratch",
        "description": "Rebuild the Supabase backend from the ground up following the comprehensive OpenSpec proposal `rebuild-supabase-from-scratch`. This task establishes a production-ready backend, including an advanced database schema, robust authentication, fine-grained security policies, and scalable serverless functions, all based on 2025 best practices.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "## OpenSpec Proposal\n- **Proposal ID**: `rebuild-supabase-from-scratch`\n- **Status**: approved\n- **Location**: `openspec/changes/rebuild-supabase-from-scratch/`\n\nThis task implements the full backend architecture as defined in the `rebuild-supabase-from-scratch` OpenSpec. The implementation will follow the 4-agent strategy detailed in the proposal's `tasks.md` to ensure a clear separation of concerns and expert-level execution for each component.\n\n### 1. Agent 1: Infrastructure & Database Foundation\n- **Responsibility**: Local Environment Setup, Core Schema, and Migrations.\n- Initialize the local Supabase environment and create the core database schema for entities like `events`, `team_members`, `partners`, and `gallery_items` through SQL migration files.\n\n### 2. Agent 2: Authentication & Security Layer\n- **Responsibility**: User Profile Management and Auth Triggers.\n- Create the `profiles` table to store user-specific data, an `updated_at` trigger for automatic timestamp management, and a trigger to populate the `profiles` table upon new user registration.\n\n### 3. Agent 3: Row-Level Security Implementation\n- **Responsibility**: Fine-Grained Access Control.\n- Enable RLS on all tables with a default-deny policy. Implement specific policies for public read access and more privileged access for authenticated and admin users, securing the application's data layer.\n\n### 4. Agent 4: Storage & Edge Functions\n- **Responsibility**: File Storage and Serverless Logic.\n- Configure Supabase Storage buckets (`media`, `avatars`) with appropriate security policies. Implement initial Deno-based Edge Functions for server-side logic such as handling contact form submissions.",
        "testStrategy": "Verification will follow the 4-agent structure, ensuring each area of responsibility is thoroughly tested.\n\n1.  **Infrastructure & Database**: Execute `supabase db reset` to validate all migration files. Use a DB client to inspect the final schema, ensuring tables (`events`, `team_members`, etc.) match the spec. \n\n2.  **Authentication Layer**: Verify the `profiles` table and `updated_at` function exist. Register a new user and confirm the signup trigger correctly creates a corresponding row in the `profiles` table.\n\n3.  **Row-Level Security**: Write a dedicated test suite (e.g., using Vitest) to test RLS policies. The suite must impersonate anonymous, authenticated, and admin roles to attempt CRUD operations on all tables and assert that permissions are enforced correctly.\n\n4.  **Storage & Edge Functions**: Test file operations (upload, download, delete) on storage buckets for each user role. Test Edge Functions locally using `supabase functions serve` and write integration tests to validate their behavior.",
        "subtasks": [
          {
            "id": 11,
            "title": "Agent 1: Initialize Local Supabase Project and Link to Remote",
            "description": "Initialize the local development environment using the Supabase CLI, link it to the remote Supabase project, and establish the basic workflow.",
            "dependencies": [],
            "details": "**1. Clean Slate Setup:**\n- Remove existing `supabase/` directory if present\n- Execute `supabase init` to create new local development environment\n\n**2. Project Linking:**\n- Create new project in Supabase dashboard and obtain project reference\n- Link local environment: `supabase link --project-ref <project-ref>`\n- Configure `.env` file with local and remote credentials\n\n**3. Verification:**\n- Verify connection: `supabase status` shows healthy local services\n- Confirm project linking: `supabase db remote changes` reports no changes\n- Ensure `supabase/migrations` directory is created\n\n**4. Documentation:**\n- Document the standard workflow (`supabase start`, `supabase db reset`, `supabase gen types`)\n- Create `.env.example` template for team members",
            "status": "done",
            "testStrategy": "Confirm `supabase status` shows all local services are active. Verify the project is linked by running a remote command like `supabase db pull`. Ensure `supabase/migrations` directory is created.",
            "parentId": "11"
          },
          {
            "id": 11,
            "title": "Agent 1: Database Schema Migration for Core Entities (Enhanced)",
            "description": "Create the first SQL migration file for the core data schema, including tables for events, team_members, partners, and gallery_items.",
            "dependencies": [
              "11.1"
            ],
            "details": "Create migration: `supabase migration new 01_database_schema`\n\n**1. Implement 3NF Normalized Schema:**\n- Create `events` table with UUID primary key, strategic denormalization columns\n- Create `partners`, `team_members`, `gallery_items` with proper relationships\n- Use PostgreSQL advanced types: `uuid`, `timestamptz`, `jsonb`\n\n**2. Strategic Denormalization for Performance:**\n- Add `partner_name` column in `events` table for read optimization\n- Implement triggers to keep denormalized data synchronized:\n```sql\nCREATE OR REPLACE FUNCTION update_event_partner_name() \nRETURNS TRIGGER AS $$\nBEGIN\n  UPDATE events SET partner_name = NEW.name WHERE partner_id = NEW.id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER on_partner_name_update\nAFTER UPDATE OF name ON partners\nFOR EACH ROW EXECUTE FUNCTION update_event_partner_name();\n```\n\n**3. Advanced Indexing Strategy:**\n```sql\n-- Foreign key indexes (mandatory)\nCREATE INDEX idx_events_partner_id ON events(partner_id);\n\n-- WHERE clause optimization\nCREATE INDEX idx_events_category ON events(category);\nCREATE INDEX idx_events_start_date ON events(start_date DESC);\nCREATE INDEX idx_events_status ON events(status) WHERE status = 'published';\n\n-- Full-text search with pg_trgm\nCREATE EXTENSION IF NOT EXISTS pg_trgm;\nCREATE INDEX idx_events_search ON events USING gin (title gin_trgm_ops, description gin_trgm_ops);\n```\n\n**4. Database Views and Functions:**\n- Create `public_events_view` for simplified public queries:\n```sql\nCREATE OR REPLACE VIEW public_events_view AS\nSELECT e.id, e.title, e.start_date, e.featured_image, \n       p.name as partner_name, p.logo_url as partner_logo\nFROM events e\nLEFT JOIN partners p ON e.partner_id = p.id\nWHERE e.status = 'published';\n```\n- Implement RPC functions for complex multi-table operations\n- Create materialized views for analytics data",
            "status": "done",
            "testStrategy": "Run `supabase db reset` to apply the migration. Connect to the local database and verify that all specified tables and columns have been created correctly. Check for primary keys, foreign keys, and default values.",
            "parentId": "11"
          },
          {
            "id": 11,
            "title": "Agent 2: Auth Schema: Create `profiles` Table and `updated_at` Trigger",
            "description": "Create a migration for the `profiles` table to store public user data and a reusable trigger function to automatically update `updated_at` timestamps.",
            "dependencies": [
              "11.2"
            ],
            "details": "Create migration: `supabase migration new 02_auth_schema`\n\n**1. Enhanced profiles table with RBAC:**\n```sql\nCREATE TABLE public.profiles (\n    id uuid REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,\n    username text UNIQUE,\n    full_name text,\n    avatar_url text,\n    role text DEFAULT 'user' CHECK (role IN ('admin', 'editor', 'user')),\n    metadata jsonb DEFAULT '{}',\n    created_at timestamptz DEFAULT now(),\n    updated_at timestamptz DEFAULT now()\n);\n```\n\n**2. Custom JWT Claims for Role-Based Access Control:**\n```sql\nCREATE OR REPLACE FUNCTION public.update_user_claims()\nRETURNS TRIGGER AS $$\nBEGIN\n  UPDATE auth.users\n  SET raw_app_meta_data = raw_app_meta_data || jsonb_build_object('role', NEW.role)\n  WHERE id = NEW.id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER on_profile_role_update\nAFTER UPDATE OF role ON public.profiles\nFOR EACH ROW EXECUTE FUNCTION public.update_user_claims();\n```\n\n**3. Enhanced `updated_at` Trigger:**\n```sql\nCREATE OR REPLACE FUNCTION handle_updated_at()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n```\n\n**4. Audit Logging Setup:**\n```sql\nCREATE TABLE public.audit_log (\n    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,\n    table_name text NOT NULL,\n    record_id uuid NOT NULL,\n    action text NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),\n    old_data jsonb,\n    new_data jsonb,\n    user_id uuid REFERENCES auth.users(id),\n    created_at timestamptz DEFAULT now()\n);\n```",
            "status": "done",
            "testStrategy": "Run `supabase db reset`. Verify the `profiles` table exists and is linked to `auth.users`. Manually run an `UPDATE` on a test row in a table with the trigger and confirm its `updated_at` column is automatically set to the current timestamp.",
            "parentId": "11"
          },
          {
            "id": 11,
            "title": "Agent 2: Create Trigger to Populate `profiles` Table on New User Signup",
            "description": "Implement a database trigger that automatically creates a new entry in the `profiles` table whenever a new user signs up via Supabase Auth.",
            "dependencies": [
              "11.3"
            ],
            "details": "Create migration: `supabase migration new 03_user_signup_automation`\n\n**1. Implement automatic profile creation:**\n```sql\nCREATE OR REPLACE FUNCTION public.handle_new_user()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO public.profiles (id, full_name, avatar_url, role)\n  VALUES (\n    NEW.id,\n    COALESCE(NEW.raw_user_meta_data->>'full_name', ''),\n    COALESCE(NEW.raw_user_meta_data->>'avatar_url', ''),\n    'user'\n  );\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n```\n\n**2. Create trigger for automatic execution:**\n```sql\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();\n\nCREATE TRIGGER on_profile_role_update\n  AFTER UPDATE OF role ON public.profiles\n  FOR EACH ROW EXECUTE FUNCTION public.update_user_claims();\n```\n\n**3. Testing:** Verify trigger creates profiles for new signups and automatically propagates role to JWT claims.",
            "status": "done",
            "testStrategy": "Create a new user via the Supabase JS client or UI. Query the `profiles` table to confirm that a corresponding record was automatically created with the correct `user_id` and any available metadata.",
            "parentId": "11"
          },
          {
            "id": 11,
            "title": "Agent 3: Row-Level Security (RLS) for Public Read Access (Enhanced)",
            "description": "Enable Row-Level Security on all core tables and implement policies that allow public, read-only access to non-sensitive data.",
            "dependencies": [
              "11.2"
            ],
            "details": "Create migration: `supabase migration new 04_rls_public_access`\n\n**1. Default Deny Principle (Security Foundation):**\n```sql\n-- Enable RLS on all tables\nALTER TABLE public.events ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.partners ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.team_members ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.gallery_items ENABLE ROW LEVEL SECURITY;\n\n-- CRITICAL: Default deny policy\nCREATE POLICY \"default_deny_all\" ON public.events FOR ALL USING (false);\nCREATE POLICY \"default_deny_all\" ON public.partners FOR ALL USING (false);\nCREATE POLICY \"default_deny_all\" ON public.team_members FOR ALL USING (false);\nCREATE POLICY \"default_deny_all\" ON public.gallery_items FOR ALL USING (false);\n```\n\n**2. Helper Functions for JWT Claims:**\n```sql\nCREATE OR REPLACE FUNCTION get_my_claim(claim TEXT) RETURNS JSONB AS $$\n  SELECT coalesce(current_setting('request.jwt.claims', true)::jsonb -> 'app_metadata' -> claim, 'null'::jsonb);\n$$ LANGUAGE sql STABLE SECURITY DEFINER;\n```\n\n**3. Public Read Access Policies:**\n```sql\n-- Public events (published only)\nCREATE POLICY \"public_read_published_events\" ON public.events\nFOR SELECT USING (status = 'published');\n\n-- Public partners (active only)\nCREATE POLICY \"public_read_active_partners\" ON public.partners\nFOR SELECT USING (status = 'active');\n\n-- Public team members\nCREATE POLICY \"public_read_team\" ON public.team_members\nFOR SELECT USING (status = 'active');\n\n-- Public gallery items\nCREATE POLICY \"public_read_gallery\" ON public.gallery_items\nFOR SELECT USING (status = 'published');\n```",
            "status": "done",
            "testStrategy": "Using a JS test suite (e.g., Vitest), initialize an anonymous Supabase client. Perform `select` queries on tables like `events` and `gallery_items` and assert that data is returned. Attempt `insert`, `update`, or `delete` and assert that they fail due to RLS.",
            "parentId": "11"
          },
          {
            "id": 11,
            "title": "Agent 3: Row-Level Security (RLS) for Authenticated and Admin Users (Enhanced)",
            "description": "Implement RLS policies that grant appropriate create, update, and delete permissions to authenticated users and elevated permissions for admin roles.",
            "dependencies": [
              "11.4",
              "11.5"
            ],
            "details": "Create migration: `supabase migration new 05_rls_admin_authenticated`\n\n**1. Role-Based Admin Policies:**\n```sql\n-- Admin full access policies for all tables\nCREATE POLICY \"admin_full_access_events\" ON public.events\nFOR ALL USING ((get_my_claim('role') ->> 'role') = 'admin')\nWITH CHECK ((get_my_claim('role') ->> 'role') = 'admin');\n\nCREATE POLICY \"admin_full_access_partners\" ON public.partners\nFOR ALL USING ((get_my_claim('role') ->> 'role') = 'admin')\nWITH CHECK ((get_my_claim('role') ->> 'role') = 'admin');\n```\n\n**2. User Profile Management:**\n```sql\n-- Users can manage their own profiles\nCREATE POLICY \"users_update_own_profile\" ON public.profiles\nFOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);\n\n-- Users can read all profiles (for public team members)\nCREATE POLICY \"read_profiles_public\" ON public.profiles\nFOR SELECT USING (true);\n```\n\n**3. Authenticated User Basic Access:**\n```sql\n-- Authenticated users can read all published content\nCREATE POLICY \"authenticated_read_published\" ON public.events\nFOR SELECT USING (auth.role() = 'authenticated' AND status = 'published');\n```\n\n**4. Enhanced Storage Policies:**\n```sql\n-- Admin upload to public media\nCREATE POLICY \"admin_upload_public_media\" ON storage.objects\nFOR INSERT TO authenticated\nWITH CHECK (bucket_id = 'public_media' AND (get_my_claim('role') ->> 'role') = 'admin');\n\n-- User avatar management\nCREATE POLICY \"user_manage_own_avatar\" ON storage.objects\nFOR ALL TO authenticated\nUSING (bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text)\nWITH CHECK (bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text);\n```",
            "status": "done",
            "testStrategy": "Extend the RLS test suite. Create test users with 'authenticated' and 'admin' roles. For each role, attempt CRUD operations on all tables and assert that permissions succeed or fail exactly as defined in the policies.",
            "parentId": "11"
          },
          {
            "id": 11,
            "title": "Agent 4: Configure Storage Buckets and Edge Functions (Enhanced)",
            "description": "Set up storage buckets for public media and private avatars, secure them with RLS policies, and implement initial serverless Edge Functions.",
            "dependencies": [
              "11.1",
              "11.5"
            ],
            "details": "Create migration: `supabase migration new 06_storage_and_functions`\n\n**1. Optimized Storage Buckets with RLS:**\n```sql\n-- Create optimized buckets\nINSERT INTO storage.buckets (id, name, public) VALUES \n('public_media', 'public_media', true),\n('avatars', 'avatars', false),\n('admin_content', 'admin_content', false);\n```\n\n**2. Advanced Storage RLS Policies:**\n```sql\n-- Public read access to media (CDN cached)\nCREATE POLICY \"public_read_media_optimized\" ON storage.objects\nFOR SELECT USING (\n  bucket_id = 'public_media' \n  AND (storage.foldername(name))[1] IN ('events', 'partners', 'gallery')\n);\n\n-- Admin full control\nCREATE POLICY \"admin_storage_full_access\" ON storage.objects\nFOR ALL USING ((get_my_claim('role') ->> 'role') = 'admin')\nWITH CHECK ((get_my_claim('role') ->> 'role') = 'admin');\n```\n\n**3. Edge Functions for Complex Operations:**\n```bash\n# Initialize Edge Functions\nsupabase functions new admin-bulk-operations\n```\n\n**4. Production Edge Function Template:**\n```typescript\n// functions/admin-bulk-operations/index.ts\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2'\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n}\n\nDeno.serve(async (req) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders })\n  }\n\n  try {\n    // Create admin client\n    const supabaseAdmin = createClient(\n      Deno.env.get('SUPABASE_URL')!,\n      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!\n    )\n\n    const { operation, data } = await req.json()\n\n    // Bulk operations with proper validation\n    switch (operation) {\n      case 'archive_past_events':\n        const result = await supabaseAdmin\n          .from('events')\n          .update({ status: 'archived' })\n          .lt('end_date', new Date().toISOString())\n        break\n    }\n\n    return new Response(JSON.stringify({ success: true }), {\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    return new Response(JSON.stringify({ error: error.message }), {\n      status: 400,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  }\n})\n```\n\n**5. Performance Monitoring & Security:**\n```sql\n-- Create performance monitoring view\nCREATE VIEW database_performance AS\nSELECT \n  schemaname, tablename,\n  n_tup_ins as inserts, n_tup_upd as updates, n_tup_del as deletes,\n  n_live_tup as live_tuples, n_dead_tup as dead_tuples\nFROM pg_stat_user_tables;\n```",
            "status": "done",
            "testStrategy": "For storage, write tests to upload/download/delete files from each bucket as an anonymous user, authenticated user, and admin, asserting that the storage RLS policies work. For functions, run `supabase functions serve` and use a tool like `curl` or a test script to invoke the `contact-form-handler` and verify the response.",
            "parentId": "11"
          }
        ],
        "complexity": 10,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Create a detailed subtask breakdown. Create one subtask for project initialization. Create separate subtasks for each major table's SQL migration script. Dedicate a subtask to setting up the auth trigger for `profiles`. Create two separate subtasks for RLS: one for public-read policies and another for authenticated/admin write policies. Finally, create subtasks for Storage configuration and Edge Function setup.",
        "updatedAt": "2025-11-07T05:13:55.968Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-07T05:13:55.969Z",
      "taskCount": 11,
      "completedCount": 4,
      "tags": [
        "master"
      ],
      "created": "2025-11-07T06:02:41.440Z",
      "description": "Tasks for master context",
      "updated": "2025-11-07T06:13:22.596Z"
    }
  }
}