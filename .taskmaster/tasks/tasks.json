{
  "master": {
    "tasks": [
      {
        "id": 13,
        "title": "Setup Foundational TypeScript Types",
        "description": "Define all global TypeScript types for domain entities like Event, Team Member, Partner, etc., to ensure type safety across the application. These will serve as the single source of truth for data structures.",
        "details": "Create type definition files under `src/types/`. Define interfaces for `Event`, `TeamMember`, `Partner`, `GalleryItem`, `HeroContent`, and `SiteSettings` as specified in the PRD's data models. A key step is to generate types from the Supabase schema to ensure alignment. Use the Supabase CLI: `npx supabase gen types typescript --project-id <YOUR_PROJECT_ID> > src/supabase/types.ts`. Then, import these generated types into your main type definition files to build upon them.",
        "testStrategy": "Validate by running the TypeScript compiler (`npx tsc --noEmit`) across the project. Success is defined as zero type errors. Also, verify that IDE IntelliSense correctly provides autocompletion for all defined types when used in other files.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Finalized Tailwind CSS v4 and Shadcn/ui Configuration",
        "description": "Finalized the configuration of Tailwind CSS v4 and its integration with Shadcn/ui. This involved adding the Vite plugin, creating the Tailwind theme configuration, refining global CSS variables, creating the class-merging utility, and verifying the setup.",
        "details": "The Tailwind CSS v4 setup has been completed. The `@tailwindcss/vite` plugin was added to `vite.config.ts`. The `tailwind.config.ts` was configured with the shadcn/ui theme and `darkMode: 'class'`. The `src/styles/globals.css` file was updated with `@tailwind` directives and the necessary CSS variables for light/dark themes. The `cn` utility function was created in `src/lib/utils.ts`. Finally, global styles were imported in `src/main.tsx` and verified.",
        "testStrategy": "Applied Tailwind utility classes to a test component in `App.tsx` and verified that styles were applied correctly. The `cn` utility was used to conditionally apply classes and the output was confirmed. Manually toggled the 'dark' class on the `<html>` element in the browser's dev tools to confirm dark mode styles worked as expected. The build process was checked to ensure it purged unused CSS.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1400,
            "title": "Install Tailwind and Utility Dependencies",
            "description": "Install packages required for Tailwind CSS v4, shadcn/ui, and utility functions.",
            "dependencies": [],
            "details": "The required development dependencies have been installed using pnpm. This includes `@tailwindcss/vite` for Vite integration, `tailwindcss-animate` for animations, and `clsx` with `tailwind-merge` for the class-merging utility function. This step is complete.",
            "status": "completed",
            "testStrategy": "Confirm that `@tailwindcss/vite`, `tailwindcss-animate`, `clsx`, and `tailwind-merge` are present in the `devDependencies` section of `package.json`. Running `pnpm install` should complete without any dependency resolution errors."
          },
          {
            "id": 1401,
            "title": "Configure Vite with TailwindCSS Plugin",
            "description": "Update the `vite.config.ts` file to import and use the `@tailwindcss/vite` plugin.",
            "dependencies": [
              1400
            ],
            "details": "Import `tailwindcss` from `@tailwindcss/vite` and add it to the `plugins` array in the `defineConfig` call within `vite.config.ts`. This enables Tailwind to process styles during development and build.",
            "status": "completed",
            "testStrategy": "Run the Vite development server. Check for any console errors related to Tailwind CSS. A successful start indicates the plugin is loaded correctly."
          },
          {
            "id": 1402,
            "title": "Created and Configured tailwind.config.ts for Shadcn",
            "description": "Create the `tailwind.config.ts` file and populate it with the theme required by shadcn/ui.",
            "dependencies": [
              1401
            ],
            "details": "Created `tailwind.config.ts` at the project root. The `content` array was configured to scan `src/**/*.{ts,tsx}` files. `darkMode: 'class'` was set. The `theme` object was configured with `container`, `extend` `colors`, `borderRadius`, `keyframes`, and `animation` with the values provided by the shadcn/ui documentation. The `tailwindcss-animate` plugin was added to the `plugins` array.",
            "status": "completed",
            "testStrategy": "A custom color (e.g., `bg-primary`) was applied to an element and verified in the browser that the correct hex code was applied."
          },
          {
            "id": 1403,
            "title": "Refined and Finalized globals.css",
            "description": "Update the existing `src/styles/globals.css` to include all necessary base styles, layers, and CSS variables for the shadcn/ui theme.",
            "dependencies": [
              1402
            ],
            "details": "In `src/styles/globals.css`, the `@tailwind` directives for `base`, `components`, and `utilities` were added. Below these, the full set of CSS variables for colors, radius, etc., were defined within `@layer base`. Separate variable sets were defined for the root `:root` (light theme) and `.dark` selectors.",
            "status": "completed",
            "testStrategy": "The `<html>` element was inspected in the browser to verify all CSS variables (`--background`, `--foreground`, etc.) were defined. The `.dark` class was toggled on the `<html>` element and it was verified that the CSS variable values updated."
          },
          {
            "id": 1404,
            "title": "Created cn() Class-Merging Utility",
            "description": "Create a `cn.ts` utility file that exports a function for safely merging Tailwind CSS classes.",
            "dependencies": [
              1400
            ],
            "details": "Created a file at `src/lib/utils.ts`. Imported `type { ClassValue } from 'clsx'`, `clsx` from `clsx`, and `twMerge` from `tailwind-merge`. Exported a function `cn` that takes `...inputs: ClassValue[]` and returns `twMerge(clsx(inputs))`. This utility is essential for building components with variant styles.",
            "status": "completed",
            "testStrategy": "A test case was run that called `cn('p-4', 'p-2')` and asserted that the result was `'p-2'`, demonstrating the merging logic."
          },
          {
            "id": 1405,
            "title": "Verify Global Style Import and Final Dev Test",
            "description": "Final verification step to ensure global styles are applied to the application and that the Tailwind setup is fully functional in a development environment.",
            "dependencies": [
              1403,
              1404
            ],
            "details": "Ensured that the main stylesheet (`src/styles/globals.css`) is imported into the application's entry point (`src/main.tsx`) so that all base styles and variables are loaded. Performed a final check by running the development server and applying test classes to a component to confirm the entire setup works end-to-end.",
            "status": "completed",
            "testStrategy": "Ran `pnpm dev` and opened the application in the browser. Added a test component with Tailwind classes and verified it was styled. Toggled dark mode to confirm it worked. This confirms the CSS is being processed and applied correctly."
          }
        ]
      },
      {
        "id": 15,
        "title": "Initialize Supabase Client Configuration",
        "description": "Set up and configure the Supabase JavaScript client to enable communication with the Supabase backend for database operations, authentication, and storage.",
        "details": "Install the Supabase client library: `npm install @supabase/supabase-js`. Create a file at `src/supabase/client.ts`. Initialize the client using `createClient` from `@supabase/supabase-js`. Store your Supabase URL and anon key in `.env.local` as `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` and access them via `import.meta.env`. Export a single, memoized instance of the client.",
        "testStrategy": "Write a small test script or a temporary component that attempts to fetch a simple list (e.g., `supabase.from('some_table').select('*')`). A successful connection without authentication or RLS errors confirms the setup is correct. Ensure environment variables are not exposed in the client-side bundle.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Create Core Utility Functions Module",
        "description": "Develop a set of common, reusable utility functions for tasks like date formatting, string manipulation, and input validation, to be used throughout the application.",
        "details": "Create files under `src/utils/`, such as `formatting.ts` and `validation.ts`. For `formatting.ts`, add functions like `formatDate(date)` and `formatCurrency(amount)`. For `validation.ts`, create functions like `isValidEmail(email)`. The `cn` utility for class names is handled in the Tailwind setup task (Task 14).",
        "testStrategy": "Implement unit tests for each utility function using a framework like Vitest. Test for expected outputs with valid inputs, and test edge cases like null, undefined, or malformed inputs to ensure they are handled gracefully without crashing.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Add Core shadcn/ui Components",
        "description": "The core set of shadcn/ui components has been successfully integrated into the project. This includes Button, Input, Card, Dialog, Badge, and Separator, which now form the foundation of the application's UI.",
        "details": "The shadcn/ui library was initialized, creating `src/components/ui` and `components.json`. Core components (`button`, `input`, `card`, `dialog`, `badge`, `separator`) were added via the CLI. The `cn` utility in `src/lib/utils.ts` is integrated, and the setup is verified to be working with the project's Tailwind CSS v4 theme, including light/dark modes.",
        "testStrategy": "Verification was done by importing components into a test page (`App.tsx`) to confirm correct rendering and theme response (light/dark mode). Storybook stories for each component have been created to test props, variants, and accessibility, confirming the integration's success.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1701,
            "title": "Initialize shadcn/ui in the project",
            "description": "Run the `npx shadcn-ui@latest init` command to set up the foundational configuration, including `components.json` and the `src/components/ui` directory.",
            "dependencies": [],
            "details": "This step configures the project to use shadcn/ui, specifying styles, Tailwind CSS settings, and the location for UI components. The process was completed successfully.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 1702,
            "title": "Add foundational UI components via CLI",
            "description": "Use the shadcn/ui CLI to add the first set of essential components: Button, Input, Card, and Dialog.",
            "dependencies": [
              1701
            ],
            "details": "The command `npx shadcn-ui@latest add button input card dialog` was executed, populating the `src/components/ui` directory with the corresponding component files.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 1703,
            "title": "Add supplementary UI components",
            "description": "Add Badge and Separator components to the UI library to support layout and information display needs.",
            "dependencies": [
              1701
            ],
            "details": "The command `npx shadcn-ui@latest add badge separator` was executed to add these components to the `src/components/ui` directory.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 1704,
            "title": "Confirm integration of 'cn' utility function",
            "description": "Verify that the `cn` utility function for conditional class names is available in `src/lib/utils.ts` and is correctly used by the new shadcn/ui components.",
            "dependencies": [
              1701
            ],
            "details": "The initialization process created `src/lib/utils.ts` which exports the `cn` function. The newly added component files import and use this utility.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 1705,
            "title": "Performed initial smoke test for a core component",
            "description": "The `<Button />` component was rendered in `App.tsx` to verify correct styling and theme application (light/dark mode). The test was successful.",
            "dependencies": [
              1702
            ],
            "details": "A `<Button>` was added to the main application component and its appearance was verified in both light and dark modes, confirming the theme and CSS variables are correctly configured.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 1706,
            "title": "Created comprehensive tests for all added components",
            "description": "Storybook stories were created for each added component (Button, Input, Card, Dialog, Badge, Separator) to document usage and verify functionality.",
            "dependencies": [
              1702,
              1703
            ],
            "details": "Individual stories were created for each component's variants, sizes, and states (e.g., disabled, hover). Interactive components were tested for event handling, and all components were checked for accessibility, completing the verification process.",
            "status": "done",
            "testStrategy": null
          }
        ]
      },
      {
        "id": 18,
        "title": "Implement Toast Notifications with Sonner",
        "description": "Integrate the Sonner library to provide non-blocking toast notifications for user feedback on actions like success, error, or information.",
        "details": "Install the library: `npm install sonner`. Add the `<Toaster />` component to the root of your application layout (`App.tsx` or `DashboardLayout.tsx`). Use the `toast()` function exported from `sonner` to trigger notifications from anywhere in the app, for example: `toast.success('Event created successfully!')`.",
        "testStrategy": "Create temporary buttons in the UI to trigger different types of toasts (success, error, info, promise). Verify that they appear correctly, are styled as expected, and disappear automatically or can be dismissed by the user.",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Form Management with React Hook Form",
        "description": "Integrate React Hook Form and create reusable form components for handling complex form state, validation, and submission efficiently.",
        "details": "Install dependencies: `npm install react-hook-form @hookform/resolvers zod`. Create a generic `<Form />` component using `shadcn/ui`'s form components which are built on `react-hook-form`. Use `zod` to define validation schemas that align with your TypeScript types. Use the `@hookform/resolvers/zod` adapter to connect Zod schemas to your forms for real-time validation.",
        "testStrategy": "Build a sample form with various input types (text, select, checkbox). Test the happy path: valid submission. Test validation: ensure error messages appear for invalid fields and submission is blocked. Test that the form state is reset correctly after submission.",
        "priority": "high",
        "dependencies": [
          13,
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Custom Client-Side Router",
        "description": "Develop a lightweight, custom client-side router using React Context and the browser's History API to manage navigation between the landing page, all-events page, and admin dashboard.",
        "details": "Create `src/components/Router.tsx`. Implement a `RouterProvider` that uses `React.createContext` to provide the current path and a `navigate` function. Use `useState` to hold the current path, initialized from `window.location.pathname`. Use a `useEffect` hook to listen to the `popstate` event to handle browser back/forward buttons. The `navigate` function should use `window.history.pushState` and update the internal state.",
        "testStrategy": "Wrap the main `App.tsx` with the `RouterProvider`. Create navigation links and test that clicking them updates the URL in the browser bar and renders the correct page component without a full page reload. Test that the browser's back and forward buttons work as expected.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Global ContentContext for State Management",
        "description": "Create a global React Context to manage the state of all primary content entities (events, team, partners, etc.), providing a centralized place for data fetching, caching, and mutations.",
        "details": "Create `src/contexts/ContentContext.tsx`. The context provider will manage state for `events`, `team`, `partners`, `gallery`, etc., along with their `loading` and `error` states. It will expose functions like `fetchEvents()`, `addEvent(newEvent)`, `updateEvent(id, data)`, etc. These functions will interact with the Supabase client and update the context state, acting as a simple client-side cache.",
        "testStrategy": "Write unit tests for the context's reducer or state update logic. Create a test component that consumes the context, calls a fetch function, and verifies that the `loading` state changes correctly and the final data is populated. Mock the Supabase client to isolate the context logic.",
        "priority": "high",
        "dependencies": [
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Develop Custom Hooks for Business Logic",
        "description": "Create custom hooks like `useEvents` and `useRouter` to abstract away business logic and interactions with context, simplifying component code.",
        "details": "Create files in `src/hooks/`. The `useRouter` hook will simply be `return useContext(RouterContext)`. The `useEvents` hook will consume the `ContentContext` and return the `events` state, loading/error status, and the event-specific functions (`addEvent`, `updateEvent`, etc.). This encapsulates the logic for interacting with the global state.",
        "testStrategy": "Test the hooks within components. For `useEvents`, verify that a component using it re-renders when the event data changes in the `ContentContext`. For `useRouter`, verify it provides the correct navigation functions and current path.",
        "priority": "medium",
        "dependencies": [
          20,
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Admin Authentication Flow",
        "description": "Set up a secure authentication mechanism for the admin dashboard using Supabase Auth, including login, session management, and protected routes.",
        "details": "Utilize Supabase Auth with the email/password or magic link provider. Create a login page for the admin dashboard. On successful login, Supabase's client handles the session. Create a protected route component that checks for an active user session (`supabase.auth.getSession()`). If no session exists, it redirects to the login page. The admin dashboard will be wrapped in this protected route.",
        "testStrategy": "Manually test the auth flow. 1) Attempt to access an admin URL directly and verify redirection to the login page. 2) Log in with valid credentials and verify access is granted. 3) Log out and verify session is terminated and user is redirected. 4) Check for the `sb-` auth token in browser storage.",
        "priority": "high",
        "dependencies": [
          15,
          18,
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Build Responsive DashboardLayout Component",
        "description": "Create the main layout for the admin dashboard, including a persistent sidebar for navigation, a header, and a main content area for dashboard pages.",
        "details": "Create `src/components/dashboard/DashboardLayout.tsx`. This component will render a sidebar with navigation links (using Lucide icons and `NavLink`-style components) to the different admin sections (Events, Team, etc.). Use CSS Grid or Flexbox to create a responsive layout that collapses the sidebar into a menu on smaller screens. The layout will render `{children}` in the main content area.",
        "testStrategy": "Wrap a sample dashboard page within the `DashboardLayout`. Verify that the layout is responsive by resizing the browser window. Test navigation by clicking sidebar links, ensuring the correct page content is loaded without the layout itself re-rendering unnecessarily.",
        "priority": "high",
        "dependencies": [
          17,
          20,
          22
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Dashboard Home Page with Statistics",
        "description": "Develop the main landing page of the admin dashboard, displaying key overview statistics and quick links to management sections.",
        "details": "Create `src/components/dashboard/DashboardHome.tsx`. This component will use the `useContent` hook to fetch summary data, such as the total number of upcoming events, total team members, and total partners. Display these stats using the `Card` component. Use a library like `Recharts` to add a simple bar chart showing events per month.",
        "testStrategy": "Verify that the dashboard home page correctly displays statistics pulled from the `ContentContext`. Manually add data to the database and refresh the page to ensure the stats update accordingly. Check that the chart renders correctly with sample data.",
        "priority": "medium",
        "dependencies": [
          21,
          22,
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Build Dashboard Event List Page",
        "description": "Create the UI for listing all events in the admin dashboard, with features for sorting, filtering, and pagination.",
        "details": "Create `src/components/dashboard/DashboardEvents.tsx`. Use the `useEvents` hook to get the list of events. Render the events in a `Table` component from `shadcn/ui`. Add controls (Input, Select) for filtering by status or searching by title. Implement client-side or server-side pagination to handle a large number of events.",
        "testStrategy": "Populate the database with a variety of events (different statuses, dates). Verify the table displays all events correctly. Test the search and filter functionality to ensure the list updates as expected. Test pagination by navigating between pages.",
        "priority": "medium",
        "dependencies": [
          22,
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Build Event Create/Edit Form and Logic",
        "description": "Implement the form for creating and editing events, including all metadata fields, validation, and submission logic to persist the data via Supabase.",
        "details": "Create `src/components/dashboard/DashboardEventsNew.tsx`. Use `react-hook-form` and a `zod` schema for validation. The form should include fields for all properties in the `Event` type, using `shadcn/ui` components like `Input`, `Textarea`, and `ReactDayPicker` for dates. The `onSubmit` handler will call the `addEvent` or `updateEvent` function from the `ContentContext` and show a success/error toast.",
        "testStrategy": "Happy path: Create a new event, fill all fields, submit, and verify it appears in the event list (Task 26) and the database. Edit an existing event and verify changes are saved. Error path: Try to submit the form with invalid data and verify that validation errors are displayed and submission is blocked.",
        "priority": "high",
        "dependencies": [
          18,
          19,
          21,
          26
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement Image Upload to Supabase Storage",
        "description": "Develop the functionality for uploading images (e.g., event featured image, team member photos) to Supabase Storage and linking the URL to the corresponding database record.",
        "details": "Integrate an image upload component into the relevant forms (e.g., Event form). Use an `<input type='file' />`. On file selection, use a library like `browser-image-compression` to resize and compress the image client-side. Then, use `supabase.storage.from('images').upload(filePath, file)` to upload it. Once the upload is complete, retrieve the public URL using `supabase.storage.from('images').getPublicUrl(filePath)` and save this URL in the appropriate database field.",
        "testStrategy": "In the event creation form, upload an image. Verify the image appears in your Supabase Storage bucket. Verify the event record in the database contains the correct public URL for the image. Check that the image loads correctly on the public-facing pages.",
        "priority": "medium",
        "dependencies": [
          15,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Build Team Member Management Page",
        "description": "Create the admin interface for CRUD operations on team members, including their name, role, bio, and photo.",
        "details": "Create `src/components/dashboard/DashboardTeam.tsx`. This will be similar in structure to the event management page. It will list existing team members and have a button to open a Dialog/Modal containing the form for adding/editing a member. The form will use `react-hook-form` and include an image uploader (reusing logic from Task 28).",
        "testStrategy": "Perform full CRUD tests: Create a new team member and verify they appear in the list. Update their details and photo, and confirm the changes. Delete the team member and ensure they are removed from the list and the database.",
        "priority": "medium",
        "dependencies": [
          24,
          27,
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Build Partner/Sponsor Management Page",
        "description": "Implement the admin interface for managing partners and sponsors, including their name, category, logo, and website URL.",
        "details": "Create `src/components/dashboard/DashboardPartners.tsx`. Follow the same pattern as Team Management (Task 29). It will feature a list of partners and a form (in a modal) for CRUD operations. The form will include fields for partner details and a logo uploader.",
        "testStrategy": "Perform full CRUD tests for partners. Verify that creating, updating, and deleting partners works correctly and that the data is accurately reflected in the database. Ensure partner logos can be uploaded and displayed.",
        "priority": "medium",
        "dependencies": [
          24,
          27,
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Build Landing Page Content Management (Hero & About)",
        "description": "Create admin interfaces for managing the content of the landing page's Hero and About sections.",
        "details": "Create `DashboardHero.tsx` and `DashboardAbout.tsx`. These will be simple forms that fetch the current content from the `ContentContext`. The forms will allow admins to update fields like the hero title, subtitle, featured event ID (using a select dropdown of events), and the about section text. On save, the `updateHeroContent` function in the context is called.",
        "testStrategy": "Load the admin pages and verify they are pre-populated with the current content. Make a change (e.g., update the hero title), save it, and then load the public-facing landing page to confirm the change is immediately visible.",
        "priority": "medium",
        "dependencies": [
          24,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Build Site Settings Management Page",
        "description": "Develop the admin page for managing global site settings, such as contact information and social media links.",
        "details": "Create `src/components/dashboard/DashboardSettings.tsx`. This will be a single form that loads the global `site_settings` object from the `ContentContext`. It will allow admins to edit the contact email, phone number, and social media URLs. On save, it updates the single settings record in the database.",
        "testStrategy": "Change a social media link in the settings form and save. Navigate to the public site's footer and verify that the link has been updated. This confirms the end-to-end flow from admin input to public display.",
        "priority": "medium",
        "dependencies": [
          24,
          27
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Build and Compose the Public Landing Page",
        "description": "Assemble the main public-facing landing page by composing various sections like Hero, Featured Events, Team, and Partners, pulling all data from the ContentContext.",
        "details": "Create `src/components/LandingPage.tsx`. This component will be the main entry point for the public site. It will use the `useContent` hook to access all necessary data. It will then render individual section components (e.g., `<HeroSection />`, `<FeaturedEventsSection />`, `<TeamSection />`, `<PartnersSection />`, `<Footer />`), passing the relevant data down as props.",
        "testStrategy": "Load the landing page and verify that all sections are rendered with the correct data from the CMS. Ensure the page is fully responsive and visually matches the Figma designs. Check that all links (e.g., to social media) are correct.",
        "priority": "high",
        "dependencies": [
          21,
          22,
          29,
          30,
          31,
          32
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Build 'All Events' Page with Filtering and Search",
        "description": "Create a dedicated page for users to browse, search, and filter all available events, with support for pagination.",
        "details": "Create `src/components/AllEventsPage.tsx`. The page will fetch all 'upcoming' events from the `ContentContext`. Implement UI controls (`Input`, `Select`, `Checkbox`) for filtering by category, date range, and a text-based search. The filtering logic can be implemented client-side for now. Render the filtered results as a grid of `EventCard` components. Add a pagination component to navigate through a large list.",
        "testStrategy": "With a large set of test events, verify that the initial list loads. Test each filter individually and in combination to ensure the event list updates correctly. Test the search functionality. Test the pagination to make sure you can navigate through all results.",
        "priority": "medium",
        "dependencies": [
          22,
          33
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implement Event Detail View/Modal",
        "description": "Create a detailed view for a single event, showing all information including the gallery, artist lineup, and venue details. This can be a modal or a separate page.",
        "details": "When a user clicks on an `EventCard` (from Task 33 or 34), open a `Dialog` modal. The modal will receive the `eventId` as a prop. It will then fetch the full event details from the `ContentContext`. The view will display all event fields, including a carousel (`Embla Carousel`) for the image gallery and a list of associated artists.",
        "testStrategy": "Click on various event cards from the landing page and the 'All Events' page. Verify that the correct event's details are loaded and displayed in the modal. Check that the image gallery is functional. Ensure the modal can be closed properly.",
        "priority": "medium",
        "dependencies": [
          33,
          34
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement Client-Side Caching Strategy",
        "description": "Optimize performance by enhancing the ContentContext to act as a more robust client-side cache, reducing redundant API calls to Supabase.",
        "details": "Refine the `ContentContext`. When a fetch function (e.g., `fetchEvents`) is called, first check if the data already exists in the context's state and is not stale. If it is, return the cached data. If not, fetch from Supabase and update the state. The mutation functions (`addEvent`, `updateEvent`) must invalidate the cache by either refetching the data or intelligently updating the local state.",
        "testStrategy": "Using browser dev tools, monitor network requests. Navigate between pages that use the same data (e.g., from landing page to all events page). Verify that the data is fetched only once initially, and subsequent navigations use the cached data from the context, resulting in no new network requests for that data.",
        "priority": "low",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Setup E2E Testing for Critical User Journeys",
        "description": "Establish an end-to-end testing suite using a framework like Playwright or Cypress to automate testing of critical user paths, such as admin event creation and public event discovery.",
        "details": "Install Playwright: `npm init playwright@latest`. Create test files in the `tests` directory. Write scripts for the following scenarios: 1) Admin logs in, creates a new event, and saves it. 2) A public user visits the site, sees the new event on the landing page, navigates to the all-events page, filters for it, and opens its detail view. Configure the tests to run against a seeded test database.",
        "testStrategy": "Run the E2E test suite via the command line (`npx playwright test`). The tests should pass consistently in a headless browser. Integrate this command into a CI/CD pipeline (e.g., GitHub Actions) to run automatically on every push or pull request to the main branch, preventing regressions.",
        "priority": "low",
        "dependencies": [
          23,
          27,
          35
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-07T06:02:41.440Z",
      "updated": "2025-11-24T13:09:52.632Z",
      "description": "Tasks for master context"
    }
  }
}